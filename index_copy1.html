<!DOCTYPE html>
<html><head lang="en">
<meta http-equiv="content-type" content="text/html; charset=UTF-8">
        <meta charset="utf-8">
        <title>BIP39 - Mnemonic Code</title>
        
        <link rel="stylesheet" href="style.css">
        
        <meta content="Mnemonic code for generating deterministic keys" name="description">
        <meta content="width=device-width, initial-scale=1.0" name="viewport">
        <meta content="bitcoin mnemonic converter" name="description">
        <meta content="Ian Coleman" name="author">
        <link type="image/x-icon" rel="icon" href="data:image/x-icon;base64,iVBORw0KGgoAAAANSUhEUgAAABAAAAAQEAYAAABPYyMiAAAABmJLR0T///////8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAF0lEQVRIx2NgGAWjYBSMglEwCkbBSAcACBAAAeaR9cIAAAAASUVORK5CYII=">
    </head>
    <body>
        <div class="container">

            <h1 class="text-center">Mnemonic Code Converter</h1>
            <p class="version">v0.5.6</p>
            <hr>
            <div class="row">
                <div class="col-md-12">
                    <h2>Mnemonic</h2>
                    <form class="form-horizontal" role="form">
                        <div class="form-group">
                            <div class="col-sm-2"></div>
                            <div class="col-sm-10">
                                <p>You can enter an existing BIP39 
mnemonic, or generate a new random one. Typing your own twelve words 
will probably not work how you expect, since the words require a 
particular structure (the last word contains a checksum).</p>
                                <p>
                                    For more info see the
                                    <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki" target="_blank">BIP39 spec</a>.
                                </p>

                                <p>
                                    <span class="text-danger">
                                        If you share the information 
generated by this page with anyone, they can steal your assets.
                                        Anyone asking you to share your 
your secret recovery phrase or BIP 32 root key is a scammer.
                                        Do NOT copy &amp; paste 
information from this page or send it to anyone offering to help you on 
Twitter, Discord, Telegram, Etherscan, or Line. 
                                        <strong>They will steal your coins.</strong>
                                    </span>
                                </p>
                            </div>
                        </div>
                        <div class="form-group generate-container">
                            <label class="col-sm-2 control-label"></label>
                            <div class="col-sm-10">
                                <div class="form-inline">
                                    <div class="input-group-inline">
                                         <span>Generate a random mnemonic</span>:
                                        <button class="btn generate"><b>GENERATE</b></button>
                                        <select id="strength" class="strength form-control">
                                            <option value="3">3</option>
                                            <option value="6">6</option>
                                            <option value="9">9</option>
                                            <option value="12">12</option>
                                            <option value="15" selected="selected">15</option>
                                            <option value="18">18</option>
                                            <option value="21">21</option>
                                            <option value="24">24</option>
                                        </select>
                                        <span>words, or enter your own below</span>.
                                        <p class="warning help-block hidden">
                                            <span class="text-danger">
                                                Mnemonics with less than
 12 words have low entropy and may be guessed by an attacker.
                                            </span>
                                        </p>
                                    </div>
                                </div>
                            </div>
                        </div>
                        <div class="entropy-container hidden">
                            <div class="form-group text-danger">
                                <label class="col-sm-2 control-label">Warning</label>
                                <div class="col-sm-10 form-control-static">
                                    <span>Entropy is an advanced feature. Your mnemonic may be insecure if this feature is used incorrectly.</span>
                                    <a href="#entropy-notes">Read more</a>
                                </div>
                            </div>
                            <div class="form-group">
                                <label for="entropy" class="col-sm-2 control-label">Entropy</label>
                                <div class="col-sm-7">
                                    <textarea id="entropy" rows="2" class="entropy private-data form-control" placeholder="Accepts either binary, base 6, 6-sided dice, base 10, hexadecimal or cards" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                                    <div class="row filter-warning text-danger hidden">
                                        <p class="col-sm-12">
                                        <strong>
                                        Some characters have been discarded
                                        </strong>
                                        </p>
                                    </div>
                                    <div class="row">
                                        <label class="col-sm-3 control-label"><span class="more-info" title="Based on estimates from zxcvbn using Filtered Entropy">Time To Crack</span></label>
                                        <div class="crack-time col-sm-3 form-control-static"></div>
                                        <label class="col-sm-3 control-label">Event Count</label>
                                        <div class="event-count col-sm-3 form-control-static"></div>
                                    </div>
                                    <div class="row">
                                        <label class="col-sm-3 control-label">Entropy Type</label>
                                        <div class="type col-sm-3 form-control-static"></div>
                                        <label class="col-sm-3 control-label">Avg Bits Per Event</label>
                                        <div class="bits-per-event col-sm-3 form-control-static"></div>
                                    </div>
                                    <div class="row">
                                        <label class="col-sm-3 control-label">Raw Entropy Words</label>
                                        <div class="word-count col-sm-3 form-control-static"></div>
                                        <label class="col-sm-3 control-label"><span class="more-info" title="Total bits of entropy may be less than indicated if any entropy event uses a weak source.">Total Bits</span></label>
                                        <div class="bits col-sm-3 form-control-static"></div>
                                    </div>
                                    <label class="col-sm-3 control-label">Filtered Entropy</label>
                                    <div class="filtered private-data col-sm-9 form-control-static"></div>
                                    <label class="col-sm-3 control-label">Raw Binary</label>
                                    <div class="binary private-data col-sm-9 form-control-static"></div>
                                    <label class="col-sm-3 control-label">Binary Checksum</label>
                                    <div class="checksum private-data col-sm-9 form-control-static">&nbsp;</div>
                                    <label class="col-sm-3 control-label">Word Indexes</label>
                                    <div class="word-indexes private-data col-sm-9 form-control-static">&nbsp;</div>
                                    <label class="col-sm-3 control-label">Mnemonic Length</label>
                                    <div class="col-sm-9">
                                        <select class="mnemonic-length form-control">
                                            <option value="raw" selected="selected">Use Raw Entropy (3 words per 32 bits)</option>
                                            <option value="12">12 Words</option>
                                            <option value="15">15 Words</option>
                                            <option value="18">18 Words</option>
                                            <option value="21">21 Words</option>
                                            <option value="24">24 Words</option>
                                        </select>
                                        <p class="weak-entropy-override-warning hidden">
                                            <span class="text-danger">
                                                The mnemonic will appear more secure than it really is.
                                            </span>
                                        </p>
                                    </div>
                                    <label class="col-sm-3 control-label">PBKDF2 rounds</label>
                                    <div class="col-sm-9">
                                        <select class="pbkdf2-rounds form-control" style="width: 60%;float: left;">
                                            <option value="2048" selected="selected">2048 (compatibility)</option>
                                            <option value="4096">4096 iterations</option>
                                            <option value="8192">8192 iterations</option>
                                            <option value="16384">16384 iterations</option>
                                            <option value="32768">32768 iterations</option>
                                            <option value="custom">Custom iterations</option>
                                        </select>
                                        <input type="number" class="form-control hidden" id="pbkdf2-custom-input" value="1" min="1" pattern="[0-9]" style="float: right;width: 40%;">
                                    </div>
                                </div>
                                <div class="col-sm-3">
                                    <p>Valid entropy values include:</p>
                                    <ul>
                                        <li>
                                            <label>
                                                <input type="radio" name="entropy-type" value="binary">
                                                <strong>Binary</strong> [0-1]<br>101010011
                                            </label>
                                        </li>
                                        <li>
                                            <label>
                                                <input type="radio" name="entropy-type" value="base 6">
                                                <strong>Base 6</strong> [0-5]<br>123434014
                                            </label>
                                        </li>
                                        <li>
                                            <label>
                                                <input type="radio" name="entropy-type" value="dice">
                                                <strong>Dice</strong> [1-6]<br>62535634
                                            </label>
                                        </li>
                                        <li>
                                            <label>
                                                <input type="radio" name="entropy-type" value="base 10">
                                                <strong>Base 10</strong> [0-9]<br>90834528
                                            </label>
                                        </li>
                                        <li>
                                            <label>
                                                <input type="radio" name="entropy-type" value="hexadecimal" checked="checked">
                                                <strong>Hex</strong> [0-9A-F]<br>4187a8bfd9
                                            </label>
                                        </li>
                                        <li>
                                            <label>
                                                <input type="radio" name="entropy-type" value="card">
                                                <strong>Card</strong> [A2-9TJQK][CDHS]<br>ahqs9dtc
                                            </label>
                                        </li>
                                    </ul>
                                </div>
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="col-sm-2"></div>
                            <div class="col-sm-10 checkbox">
                                <label>
                                    <input type="checkbox" class="use-entropy">
                                    <span>Show entropy details</span>
                                </label>
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="col-sm-2"></div>
                            <div class="col-sm-10 checkbox">
                                <label>
                                    <input type="checkbox" class="privacy-screen-toggle">
                                    <span>Hide all private info</span>
                                </label>
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="col-sm-2"></div>
                            <div class="col-sm-10 checkbox">
                                <label>
                                    <input type="checkbox" class="autoCompute" checked="checked">
                                    <span>Auto compute</span>
                                </label>
                            </div>
                        </div>
                        <div class="form-group">
                            <label class="col-sm-2 control-label">Mnemonic Language</label>
                            <div class="col-sm-10 languages">
                                <div class="form-control no-border">
                                    <a href="#english">English</a>
                                    <a href="#japanese" title="Japanese">日本語</a>
                                    <a href="#spanish" title="Spanish">Español</a>
                                    <a href="#chinese_simplified" title="Chinese (Simplified)">中文(简体)</a>
                                    <a href="#chinese_traditional" title="Chinese (Traditional)">中文(繁體)</a>
                                    <a href="#french" title="French">Français</a>
                                    <a href="#italian" title="Italian">Italiano</a>
                                    <a href="#korean" title="Korean">한국어</a>
                                    <a href="#czech" title="Czech">Čeština</a>
                                    <a href="#portuguese" title="Portuguese">Português</a>
                                </div>
                            </div>
                        </div>
                        <div class="form-group text-danger PBKDF2-infos-danger hidden">
                            <label class="col-sm-2 control-label">Warning</label>
                            <div class="col-sm-10 form-control-static">
                                <span>You are using a custom number of PBKDF2 iterations. Your BIP39 seed may not show same addresses on a different software.</span>
                                <a href="#PBKDF2-notes">Read more</a>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="phrase" class="col-sm-2 control-label">BIP39 Mnemonic</label>
                            <div class="col-sm-10">
                                <textarea id="phrase" class="phrase private-data form-control" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                            </div>
                        </div>
                        <div class="form-group">
                            <div class="splitMnemonic hidden">
                                <label for="phrase" class="col-sm-2 control-label">BIP39 Split Mnemonic</label>
                                <div class="col-sm-10">
                                    <textarea id="phraseSplit" class="phraseSplit private-data form-control" title="Only 2 of 3 cards needed to recover." rows="3"></textarea>
                                    <p class="help-block">
                                        <span id="phraseSplitWarn" class="phraseSplitWarn"></span>
                                    </p>
                                </div>
                            </div>
                            <div class="col-sm-2">
                            </div>
                            <div class="col-sm-10">
                                <label class="control-label text-weight-normal">
                                    <input type="checkbox" class="showSplitMnemonic">
                                    Show split mnemonic cards
                                </label>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="passphrase" class="col-sm-2 control-label">BIP39 Passphrase (optional)</label>
                            <div class="col-sm-10">
                                <textarea id="passphrase" class="passphrase private-data form-control" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="seed" class="col-sm-2 control-label">BIP39 Seed</label>
                            <div class="col-sm-10">
                                <textarea id="seed" class="seed private-data form-control" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="network-phrase" class="col-sm-2 control-label">Coin</label>
                            <div class="col-sm-10">
                                <select id="network-phrase" class="network form-control">
                                    <!-- populated by javascript -->
                                <option value="0">AC - Asiacoin</option><option value="1">ACC - Adcoin</option><option value="2">AGM - Argoneum</option><option value="3">ARYA - Aryacoin</option><option value="4">ATOM - Cosmos Hub</option><option value="5">AUR - Auroracoin</option><option value="6">AXE - Axe</option><option value="7">ANON - ANON</option><option value="8">BOLI - Bolivarcoin</option><option value="9">BCA - Bitcoin Atom</option><option value="10">BCH - Bitcoin Cash</option><option value="11">BEET - Beetlecoin</option><option value="12">BELA - Belacoin</option><option value="13">BLK - BlackCoin</option><option value="14">BND - Blocknode</option><option value="15">tBND - Blocknode Testnet</option><option value="16">BRIT - Britcoin</option><option value="17">BSD - Bitsend</option><option value="18">BST - BlockStamp</option><option value="19">BTA - Bata</option><option value="20" selected="selected">BTC - Bitcoin</option><option value="21">BTC - Bitcoin RegTest</option><option value="22">BTC - Bitcoin Testnet</option><option value="23">BITG - Bitcoin Green</option><option value="24">BTCP - Bitcoin Private</option><option value="25">BTCPt - Bitcoin Private Testnet</option><option value="26">BSC - Binance Smart Chain</option><option value="27">BSV - BitcoinSV</option><option value="28">BTCZ - Bitcoinz</option><option value="29">BTDX - BitCloud</option><option value="30">BTG - Bitcoin Gold</option><option value="31">BTX - Bitcore</option><option value="32">CCN - Cannacoin</option><option value="33">CESC - Cryptoescudo</option><option value="34">CDN - Canadaecoin</option><option value="35">CLAM - Clams</option><option value="36">CLO - Callisto</option><option value="37">CLUB - Clubcoin</option><option value="38">CMP - Compcoin</option><option value="39">CPU - CPUchain</option><option value="40">CRAVE - Crave</option><option value="41">CRP - CranePay</option><option value="42">CRW - Crown (Legacy)</option><option value="43">CRW - Crown</option><option value="44">CSC - CasinoCoin</option><option value="45">DASH - Dash</option><option value="46">DASH - Dash Testnet</option><option value="47">DFC - Defcoin</option><option value="48">DGB - Digibyte</option><option value="49">DGC - Digitalcoin</option><option value="50">DIVI - DIVI</option><option value="51">DIVI - DIVI Testnet</option><option value="52">DMD - Diamond</option><option value="53">DNR - Denarius</option><option value="54">DOGE - Dogecoin</option><option value="55">DOGEt - Dogecoin Testnet</option><option value="56">DXN - DEXON</option><option value="57">ECN - Ecoin</option><option value="58">EDRC - Edrcoin</option><option value="59">EFL - Egulden</option><option value="60">ELA - Elastos</option><option value="61">ELLA - Ellaism</option><option value="62">EMC2 - Einsteinium</option><option value="63">ERC - Europecoin</option><option value="64">EOS - EOSIO</option><option value="65">ERE - EtherCore</option><option value="66">ESN - Ethersocial Network</option><option value="67">ETC - Ethereum Classic</option><option value="68">ETH - Ethereum</option><option value="69">EWT - EnergyWeb</option><option value="70">EXCL - Exclusivecoin</option><option value="71">EXCC - ExchangeCoin</option><option value="72">EXP - Expanse</option><option value="73">FIO - Foundation for Interwallet Operability</option><option value="74">FIRO - Firo (Zcoin rebrand)</option><option value="75">FIX - FIX</option><option value="76">FIX - FIX Testnet</option><option value="77">FJC - Fujicoin</option><option value="78">FLASH - Flashcoin</option><option value="79">FRST - Firstcoin</option><option value="80">FTC - Feathercoin</option><option value="81">GAME - GameCredits</option><option value="82">GBX - Gobyte</option><option value="83">GCR - GCRCoin</option><option value="84">GRC - Gridcoin</option><option value="85">GRS - Groestlcoin</option><option value="86">GRS - Groestlcoin Testnet</option><option value="87">HNS - Handshake</option><option value="88">HNC - Helleniccoin</option><option value="89">HUSH - Hush (Legacy)</option><option value="90">HUSH - Hush3</option><option value="91">INSN - Insane</option><option value="92">IOP - Iop</option><option value="93">IOV - Starname</option><option value="94">IXC - Ixcoin</option><option value="95">JBS - Jumbucks</option><option value="96">KMD - Komodo</option><option value="97">KOBO - Kobocoin</option><option value="98">LBC - Library Credits</option><option value="99">LCC - Litecoincash</option><option value="100">LDCN - Landcoin</option><option value="101">LINX - Linx</option><option value="102">LKR - Lkrcoin</option><option value="103">LTC - Litecoin</option><option value="104">LTCt - Litecoin Testnet</option><option value="105">LTZ - LitecoinZ</option><option value="106">LUNA - Terra</option><option value="107">LYNX - Lynx</option><option value="108">MAZA - Maza</option><option value="109">MEC - Megacoin</option><option value="110">MIX - MIX</option><option value="111">MNX - Minexcoin</option><option value="112">MONA - Monacoin</option><option value="113">MONK - Monkey Project</option><option value="114">MOAC - MOAC</option><option value="115">MUSIC - Musicoin</option><option value="116">NANO - Nano</option><option value="117">NAV - Navcoin</option><option value="118">NAS - Nebulas</option><option value="119">NEBL - Neblio</option><option value="120">NEOS - Neoscoin</option><option value="121">NIX - NIX Platform</option><option value="122">NLG - Gulden</option><option value="123">NMC - Namecoin</option><option value="124">NRG - Energi</option><option value="125">NRO - Neurocoin</option><option value="126">NSR - Nushares</option><option value="127">NYC - Newyorkc</option><option value="128">NVC - Novacoin</option><option value="129">OK - Okcash</option><option value="130">OMNI - Omnicore</option><option value="131">ONION - DeepOnion</option><option value="132">ONX - Onixcoin</option><option value="133">PART - Particl</option><option value="134">PHR - Phore</option><option value="135">PINK - Pinkcoin</option><option value="136">PIRL - Pirl</option><option value="137">PIVX - PIVX</option><option value="138">PIVX - PIVX Testnet</option><option value="139">POA - Poa</option><option value="140">POSW - POSWcoin</option><option value="141">POT - Potcoin</option><option value="142">PPC - Peercoin</option><option value="143">PRJ - ProjectCoin</option><option value="144">PSB - Pesobit</option><option value="145">PUT - Putincoin</option><option value="146">RPD - Rapids</option><option value="147">RVN - Ravencoin</option><option value="148">R-BTC - RSK</option><option value="149">tR-BTC - RSK Testnet</option><option value="150">RBY - Rubycoin</option><option value="151">RDD - Reddcoin</option><option value="152">RITO - Ritocoin</option><option value="153">RUNE - THORChain</option><option value="154">RVR - RevolutionVR</option><option value="155">SAFE - Safecoin</option><option value="156">SCRIBE - Scribe</option><option value="157">SLS - Salus</option><option value="158">SDC - ShadowCash</option><option value="159">SDC - ShadowCash Testnet</option><option value="160">SLM - Slimcoin</option><option value="161">SLM - Slimcoin Testnet</option><option value="162">SLP - Simple Ledger Protocol</option><option value="163">SLR - Solarcoin</option><option value="164">SMLY - Smileycoin</option><option value="165">STASH - Stash</option><option value="166">STASH - Stash Testnet</option><option value="167">STRAT - Stratis</option><option value="168">SUGAR - Sugarchain</option><option value="169">TUGAR - Sugarchain Testnet</option><option value="170">SWTC - Jingtum</option><option value="171">TSTRAT - Stratis Testnet</option><option value="172">SYS - Syscoin</option><option value="173">THC - Hempcoin</option><option value="174">THT - Thought</option><option value="175">TOA - Toa</option><option value="176">TRX - Tron</option><option value="177">TWINS - TWINS</option><option value="178">TWINS - TWINS Testnet</option><option value="179">USC - Ultimatesecurecash</option><option value="180">USNBT - NuBits</option><option value="181">UNO - Unobtanium</option><option value="182">VASH - Vpncoin</option><option value="183">VET - VeChain</option><option value="184">VIA - Viacoin</option><option value="185">VIA - Viacoin Testnet</option><option value="186">VIVO - Vivo</option><option value="187">VTC - Vertcoin</option><option value="188">WGR - Wagerr</option><option value="189">WC - Wincoin</option><option value="190">XAX - Artax</option><option value="191">XBC - Bitcoinplus</option><option value="192">XLM - Stellar</option><option value="193">XMY - Myriadcoin</option><option value="194">XRP - Ripple</option><option value="195">XVC - Vcash</option><option value="196">XVG - Verge</option><option value="197">XUEZ - Xuez</option><option value="198">XWCC - Whitecoin Classic</option><option value="199">XZC - Zcoin (rebranded to Firo)</option><option value="200">ZBC - ZooBlockchain</option><option value="201">ZCL - Zclassic</option><option value="202">ZEC - Zcash</option><option value="203">ZEN - Horizen</option><option value="204">XWC - Whitecoin</option></select>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="root-key" class="col-sm-2 control-label">BIP32 Root Key</label>
                            <div class="col-sm-10">
                                <textarea id="root-key" class="root-key private-data form-control" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                            </div>
                        </div>

                        <div class="form-group">
                            <div class="col-sm-2"></div>
                            <div class="col-sm-10">
                                <label class="control-label text-weight-normal">
                                    <input type="checkbox" class="showBip85">
                                    Show BIP85
                                </label>
                            </div>
                        </div>

                        <div class="form-group bip85 hidden">
                            <div class="form-group text-danger">
                                <label class="col-sm-2 control-label">Warning</label>
                                <div class="col-sm-10 form-control-static">
                                    This is an advanced feature and should only be used if you understand what it does.
                                </div>
                            </div>
                            <div class="form-group">
                                <label class="col-sm-2"></label>
                                <div class="col-sm-10">
                                    <p>
                                    The value of the "BIP85 Child Key" field shown below is not used
                                    elsewhere on this page. It can be used as a new key.
                                    </p>
                                    <p>
                                    In case of the BIP39 application, you can paste it into the "BIP39 Mnemonic"
                                    field to use it as a new mnemonic.
                                    </p>
                                    <p>
                                    Please read the
                                    <a href="https://github.com/bitcoin/bips/blob/master/bip-0085.mediawiki" target="_blank">
                                        BIP85 spec
                                    </a>
                                    for more information.
                                    </p>
                                </div>
                            </div>
                            <label for="bip85-application" class="col-sm-2 control-label">BIP85 Application</label>
                            <div class="col-sm-10">
                                <select id="bip85-application" class="form-control">
                                    <option value="bip39" selected="selected">BIP39</option>
                                    <option value="wif">WIF</option>
                                    <option value="xprv">Xprv</option>
                                    <option value="hex">Hex</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group bip85 bip85-mnemonic-language-input hidden">
                            <label for="bip85-mnemonic-language" class="col-sm-2 control-label">BIP85 Mnemonic Language</label>
                            <div class="col-sm-10 languages">
                                <select id="bip85-mnemonic-language" class="strength form-control">
                                    <option value="0" selected="selected">English</option>
                                    <!--<option value="1">日本語</option>
                                    <option value="2">한국어</option>
                                    <option value="3">Español</option>
                                    <option value="4">中文(简体)</option>
                                    <option value="5">中文(繁體)</option>
                                    <option value="6">Français</option>
                                    <option value="7">Italiano</option>
                                    <option value="8">Čeština</option>
                                    <option value="9">Português</option>-->
                                </select>
                            </div>
                        </div>

                        <div class="form-group bip85 bip85-mnemonic-length-input hidden">
                            <label for="bip85-mnemonic-length" class="col-sm-2 control-label">BIP85 Mnemonic Length</label>
                            <div class="col-sm-10">
                                <select id="bip85-mnemonic-length" class="strength form-control">
                                    <option value="12" selected="selected">12</option>
                                    <option value="18">18</option>
                                    <option value="24">24</option>
                                </select>
                            </div>
                        </div>

                        <div class="form-group bip85 hidden">
                            <span class="bip85-bytes-input">
                                <label for="bip85-bytes" class="col-sm-2 control-label">BIP85 Bytes</label>
                                <div class="col-sm-10">
                                    <input id="bip85-bytes" type="text" class="change form-control" value="64">
                                </div>
                            </span>
                        </div>

                        <div class="form-group bip85 bip85-index-input hidden">
                            <label for="bip85-index" class="col-sm-2 control-label">BIP85 Index</label>
                            <div class="col-sm-10">
                                <input id="bip85-index" type="text" class="change form-control" value="0">
                            </div>
                        </div>

                        <div class="form-group bip85 hidden">
                            <label for="phrase" class="col-sm-2 control-label">BIP85 Child Key</label>
                            <div class="col-sm-10">
                                <textarea id="bip85Field" data-show-qr="" class="bip85Field private-data form-control" title="BIP85 Child Key" rows="3"></textarea>
                            </div>
                        </div>

                        <div class="form-group litecoin-ltub-container hidden">
                            <label for="litecoin-use-ltub" class="col-sm-2 control-label">Prefixes</label>
                            <div class="col-sm-10 checkbox">
                                <label>
                                    <input type="checkbox" id="litecoin-use-ltub" class="litecoin-use-ltub" checked="checked">
                                    Use <code>Ltpv / Ltub</code> instead of <code>xprv / xpub</code>
                                </label>
                            </div>
                        </div>
                    </form>
                </div>
            </div>

            <hr>

            <div class="row">
                <div class="col-md-12">
                    <h2>Derivation Path</h2>
                    <ul class="derivation-type nav nav-tabs" role="tablist">
                        <li id="bip32-tab">
                            <a href="#bip32" role="tab" data-toggle="tab">BIP32</a>
                        </li>
                        <li id="bip44-tab" class="active">
                            <a href="#bip44" role="tab" data-toggle="tab">BIP44</a>
                        </li>
                        <li id="bip49-tab">
                            <a href="#bip49" role="tab" data-toggle="tab">BIP49</a>
                        </li>
                        <li id="bip84-tab">
                            <a href="#bip84" role="tab" data-toggle="tab">BIP84</a>
                        </li>
                        <li id="bip141-tab">
                            <a href="#bip141" role="tab" data-toggle="tab">BIP141</a>
                        </li>
                    </ul>
                    <div class="derivation-type tab-content">
                        <div id="bip44" class="tab-pane active">
                            <form class="form-horizontal" role="form">
                                <br>
                                <div class="col-sm-2"></div>
                                <div class="col-sm-10">
                                    <p>
                                        For more info see the
                                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki" target="_blank">BIP44 spec</a>.
                                    </p>
                                </div>
                                <div class="form-group">
                                    <label for="purpose-bip44" class="col-sm-2 control-label">
                                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#purpose" target="_blank">Purpose</a>
                                    </label>
                                    <div class="col-sm-10">
                                        <input id="purpose-bip44" type="text" class="purpose form-control" value="44" readonly="readonly">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="coin-bip44" class="col-sm-2 control-label">
                                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#registered-coin-types" target="_blank">Coin</a>
                                    </label>
                                    <div class="col-sm-10">
                                        <input id="coin-bip44" type="text" class="coin form-control" value="0" readonly="readonly">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="account-bip44" class="col-sm-2 control-label">
                                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#account" target="_blank">Account</a>
                                    </label>
                                    <div class="col-sm-10">
                                        <input id="account-bip44" type="text" class="account form-control" value="0">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="change-bip44" class="col-sm-2 control-label">
                                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#change" target="_blank">External / Internal</a>
                                    </label>
                                    <div class="col-sm-10">
                                      <input id="change-bip44" type="text" class="change form-control" value="0">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="col-sm-2 control-label">
                                    </label>
                                    <div class="col-sm-10">
                                        <p>The account extended keys can be used for importing to most BIP44 compatible wallets, such as mycelium or electrum.</p>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="account-xprv" class="col-sm-2 control-label">
                                        <span>Account Extended Private Key</span>
                                    </label>
                                    <div class="col-sm-10">
                                        <textarea id="account-xprv-bip44" type="text" class="account-xprv private-data form-control" readonly="readonly" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="account-xpub" class="col-sm-2 control-label">
                                        <span>Account Extended Public Key</span>
                                    </label>
                                    <div class="col-sm-10">
                                        <textarea id="account-xpub-bip44" type="text" class="account-xpub form-control" readonly="readonly" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="col-sm-2 control-label">
                                    </label>
                                    <div class="col-sm-10">
                                        <p>The BIP32 derivation path and extended keys are the basis for the derived addresses.</p>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="bip44-path" class="col-sm-2 control-label">BIP32 Derivation Path</label>
                                    <div class="col-sm-10">
                                        <input id="bip44-path" type="text" class="path form-control" value="m/44'/0'/0'/0" readonly="readonly">
                                    </div>
                                </div>
                            </form>
                        </div>
                        <div id="bip32" class="tab-pane">
                            <form class="form-horizontal" role="form">
                                <br>
                                <div class="col-sm-2"></div>
                                <div class="col-sm-10">
                                    <p>
                                        For more info see the
                                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank">BIP32 spec</a>
                                    </p>
                                </div>
                                <div class="form-group">
                                    <label for="bip32-client" class="col-sm-2 control-label">Client</label>
                                    <div class="col-sm-10">
                                        <select id="bip32-client" class="client form-control">
                                            <option value="custom" selected="selected">Custom derivation path</option>
                                            <!-- populated by javascript -->
                                        <option value="0">Bitcoin Core</option><option value="1">blockchain.info</option><option value="2">MultiBit HD</option><option value="3">Coinomi, Ledger</option></select>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="bip32-path" class="col-sm-2 control-label">BIP32 Derivation Path</label>
                                    <div class="col-sm-10">
                                        <input id="bip32-path" type="text" class="path form-control" value="m/0">
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="core-path" class="col-sm-2 control-label">Bitcoin Core</label>
                                    <div class="col-sm-10">
                                        <p class="form-control no-border">
                                        Use path <code>m/0'/0'</code> with hardened addresses.
                                        </p>
                                        <p class="form-control no-border">
                                            For more info see the
                                            <a href="https://github.com/bitcoin/bitcoin/pull/8035" target="_blank">Bitcoin Core BIP32 implementation</a>
                                        </p>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label for="core-path" class="col-sm-2 control-label">Multibit</label>
                                    <div class="col-sm-10">
                                        <p class="form-control no-border">
                                            <span>Use path <code>m/0'/0</code>.</span>
                                            <span>For change addresses use path <code>m/0'/1</code>.</span>
                                        </p>
                                        <p class="form-control no-border">
                                            <span>For more info see</span>
                                            <a href="https://multibit.org/" target="_blank">MultiBit HD</a>
                                        </p>
                                    </div>
                                </div>
                                <div class="form-group">
                                    <label class="col-sm-2 control-label">Block Explorers</label>
                                    <div class="col-sm-10">
                                        <p class="form-control no-border">
                                            <span>Use path <code>m/44'/0'/0'</code>.</span>
                                            <span>Only enter the <code>xpub</code> extended key into block explorer search fields, never the <code>xprv</code> key.</span>
                                        </p>
                                        <p class="form-control no-border">
                                            <span>Can be used with</span>:
                                            <a href="https://blockchain.info/" target="_blank">blockchain.info</a>
                                        </p>
                                    </div>
                                </div>
                            </form>
                        </div>
                        <div id="bip49" class="tab-pane">
                            <form class="form-horizontal" role="form">
                                <br>
                                <div class="unavailable hidden">
                                    <div class="form-group">
                                        <div class="col-sm-2"></div>
                                        <div class="col-sm-10">
                                            <p>BIP49 is unavailable for this coin.</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="available">
                                    <div class="col-sm-2"></div>
                                    <div class="col-sm-10">
                                        <p>
                                            For more info see the
                                            <a href="https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki" target="_blank">BIP49 spec</a>.
                                        </p>
                                    </div>
                                    <div class="form-group">
                                        <label for="purpose-bip49" class="col-sm-2 control-label">
                                            <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#purpose" target="_blank">Purpose</a>
                                        </label>
                                        <div class="col-sm-10">
                                            <input id="purpose-bip49" type="text" class="purpose form-control" value="49" readonly="readonly">
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="coin-bip49" class="col-sm-2 control-label">
                                            <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#registered-coin-types" target="_blank">Coin</a>
                                        </label>
                                        <div class="col-sm-10">
                                            <input id="coin-bip49" type="text" class="coin form-control" value="0" readonly="readonly">
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="account-bip49" class="col-sm-2 control-label">
                                            <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#account" target="_blank">Account</a>
                                        </label>
                                        <div class="col-sm-10">
                                            <input id="account-bip49" type="text" class="account form-control" value="0">
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="change-bip49" class="col-sm-2 control-label">
                                            <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki#change" target="_blank">External / Internal</a>
                                        </label>
                                        <div class="col-sm-10">
                                            <input id="change-bip49" type="text" class="change form-control" value="0">
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label class="col-sm-2 control-label">
                                        </label>
                                        <div class="col-sm-10">
                                            <p>The account extended keys can be used for importing to most BIP49 compatible wallets.</p>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="account-xprv" class="col-sm-2 control-label">
                                            <span>Account Extended Private Key</span>
                                        </label>
                                        <div class="col-sm-10">
                                            <textarea id="account-xprv-bip49" type="text" class="account-xprv private-data form-control" readonly="readonly" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="account-xpub" class="col-sm-2 control-label">
                                            <span>Account Extended Public Key</span>
                                        </label>
                                        <div class="col-sm-10">
                                            <textarea id="account-xpub-bip49" type="text" class="account-xpub form-control" readonly="readonly" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label class="col-sm-2 control-label">
                                        </label>
                                        <div class="col-sm-10">
                                            <p>The BIP32 derivation path and extended keys are the basis for the derived addresses.</p>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="bip49-path" class="col-sm-2 control-label">BIP32 Derivation Path</label>
                                        <div class="col-sm-10">
                                            <input id="bip49-path" type="text" class="path form-control" value="m/49'/0'/0'/0" readonly="readonly">
                                        </div>
                                    </div>
                                </div>
                            </form>
                        </div>
                        <div id="bip141" class="tab-pane">
                            <form class="form-horizontal" role="form">
                                <br>
                                <div class="unavailable hidden">
                                    <div class="form-group">
                                        <div class="col-sm-2"></div>
                                        <div class="col-sm-10">
                                            <p>BIP141 is unavailable for this coin.</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="available">
                                    <div class="col-sm-2"></div>
                                    <div class="col-sm-10">
                                        <p>
                                            For more info see the
                                            <a href="https://github.com/bitcoin/bips/blob/master/bip-0141.mediawiki" target="_blank">BIP141 spec</a>
                                        </p>
                                    </div>
                                    <div class="form-group">
                                        <label for="bip141-path" class="col-sm-2 control-label">BIP32 Derivation Path</label>
                                        <div class="col-sm-10">
                                            <input id="bip141-path" type="text" class="bip141-path form-control" value="m/0">
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label class="col-sm-2 control-label">Script Semantics</label>
                                        <div class="col-sm-10">
                                            <select class="form-control bip141-semantics">
                                                <option value="p2wpkh">P2WPKH</option>
                                                <option value="p2wpkh-p2sh" selected="selected">P2WPKH nested in P2SH</option>
                                                <option value="p2wsh">P2WSH (1-of-1 multisig)</option>
                                                <option value="p2wsh-p2sh">P2WSH nested in P2SH (1-of-1 multisig)</option>
                                            </select>
                                        </div>
                                    </div>
                                </div>
                            </form>
                        </div>
                        <div id="bip84" class="tab-pane">
                            <form class="form-horizontal" role="form">
                                <br>
                                <div class="unavailable hidden">
                                    <div class="form-group">
                                        <div class="col-sm-2"></div>
                                        <div class="col-sm-10">
                                            <p>BIP84 is unavailable for this coin.</p>
                                        </div>
                                    </div>
                                </div>
                                <div class="available">
                                    <div class="col-sm-2"></div>
                                    <div class="col-sm-10">
                                        <p>
                                            For more info see the
                                            <a href="https://github.com/bitcoin/bips/blob/master/bip-0084.mediawiki" target="_blank">BIP84 spec</a>.
                                        </p>
                                    </div>
                                    <div class="form-group">
                                        <label for="purpose-bip84" class="col-sm-2 control-label">
                                            Purpose
                                        </label>
                                        <div class="col-sm-10">
                                            <input id="purpose-bip84" type="text" class="purpose form-control" value="84" readonly="readonly">
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="coin-bip84" class="col-sm-2 control-label">
                                            Coin
                                        </label>
                                        <div class="col-sm-10">
                                            <input id="coin-bip84" type="text" class="coin form-control" value="0" readonly="readonly">
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="account-bip84" class="col-sm-2 control-label">
                                            Account
                                        </label>
                                        <div class="col-sm-10">
                                            <input id="account-bip84" type="text" class="account form-control" value="0">
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="change-bip84" class="col-sm-2 control-label">
                                            External / Internal
                                        </label>
                                        <div class="col-sm-10">
                                            <input id="change-bip84" type="text" class="change form-control" value="0">
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label class="col-sm-2 control-label">
                                        </label>
                                        <div class="col-sm-10">
                                            <p>The account extended keys can be used for importing to most BIP84 compatible wallets.</p>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="account-xprv" class="col-sm-2 control-label">
                                            <span>Account Extended Private Key</span>
                                        </label>
                                        <div class="col-sm-10">
                                            <textarea id="account-xprv-bip84" type="text" class="account-xprv private-data form-control" readonly="readonly" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="account-xpub" class="col-sm-2 control-label">
                                            <span>Account Extended Public Key</span>
                                        </label>
                                        <div class="col-sm-10">
                                            <textarea id="account-xpub-bip84" type="text" class="account-xpub form-control" readonly="readonly" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label class="col-sm-2 control-label">
                                        </label>
                                        <div class="col-sm-10">
                                            <p>The BIP32 derivation path and extended keys are the basis for the derived addresses.</p>
                                        </div>
                                    </div>
                                    <div class="form-group">
                                        <label for="bip84-path" class="col-sm-2 control-label">BIP32 Derivation Path</label>
                                        <div class="col-sm-10">
                                            <input id="bip84-path" type="text" class="path form-control" value="m/84'/0'/0'/0" readonly="readonly">
                                        </div>
                                    </div>
                                </div>
                            </form>
                        </div>
                    </div>
                    <form class="form-horizontal" role="form">
                        <div class="form-group">
                            <label for="extended-priv-key" class="col-sm-2 control-label">BIP32 Extended Private Key</label>
                            <div class="col-sm-10">
                                <textarea id="extended-priv-key" class="extended-priv-key private-data form-control" readonly="readonly" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                            </div>
                        </div>
                        <div class="form-group">
                            <label for="extended-pub-key" class="col-sm-2 control-label">BIP32 Extended Public Key</label>
                            <div class="col-sm-10">
                                <textarea id="extended-pub-key" class="extended-pub-key form-control" readonly="readonly" data-show-qr="" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                            </div>
                        </div>
                    </form>
                </div>
            </div>

            <hr>

            <div class="row">
                <div class="col-md-12">
                    <h2>Derived Addresses</h2>
                    <p>Note these addresses are derived from the BIP32 Extended Key</p>
                </div>
                <div class="col-md-12 bch-addr-type-container hidden">
                    <div class="radio">
                        <label>
                            <input type="radio" value="cashaddr" name="bch-addr-type" class="use-bch-cashaddr-addresses" checked="checked">
                            <span>Use CashAddr addresses for Bitcoin Cash (ie starting with 'q' instead of '1')</span>
                        </label>
                    </div>
                    <div class="radio">
                        <label>
                            <input type="radio" value="bitpay" name="bch-addr-type" class="use-bch-bitpay-addresses">
                            <span>Use BitPay-style addresses for Bitcoin Cash (ie starting with 'C' instead of '1')</span>
                        </label>
                    </div>
                    <div class="radio">
                        <label>
                            <input type="radio" value="legacy" name="bch-addr-type" class="use-bch-legacy-addresses">
                            <span>Use legacy addresses for Bitcoin Cash (ie starting with '1')</span>
                        </label>
                    </div>
                </div>
                <div class="col-md-12">
                    <div class="checkbox">
                        <label>
                            <input type="checkbox" class="use-bip38">
                            <span>Encrypt private keys using BIP38 and this password:</span>
                        </label>
                        <input class="bip38-password private-data" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false">
                        <span>Enabling BIP38 means each key will take several minutes to generate.</span>
                    </div>
                </div>
                <div class="col-md-12">
                    <div class="checkbox">
                        <label>
                            <input class="hardened-addresses" type="checkbox">
                            <span>Use hardened addresses</span>
                        </label>
                    </div>
                </div>
                <ul class="addresses-type nav nav-tabs" role="tablist">
                    <li id="table-tab" class="active">
                        <a href="#table" role="tab" data-toggle="tab">Table</a>
                    </li>
                    <li id="csv-tab">
                        <a href="#csv" role="tab" data-toggle="tab">CSV</a>
                    </li>
                </ul>
                <div class="addresses-type tab-content">
                    <div id="table" class="tab-pane active">
                        <div class="col-md-12">
                            <table class="table table-striped">
                                <thead>
                                    <tr><th>
                                        <div class="input-group">
                                            <span>Path</span>&nbsp;&nbsp;
                                            <button class="index-toggle">Toggle</button>
                                        </div>
                                    </th>
                                    <th>
                                        <div class="input-group">
                                            <span>Address</span>&nbsp;&nbsp;
                                            <button class="address-toggle">Toggle</button>
                                        </div>
                                    </th>
                                    <th>
                                        <div class="input-group">
                                            <span>Public Key</span>&nbsp;&nbsp;
                                            <button class="public-key-toggle">Toggle</button>
                                        </div>
                                    </th>
                                    <th>
                                        <div class="input-group">
                                            <span>Private Key</span>&nbsp;&nbsp;
                                            <button class="private-key-toggle">Toggle</button>
                                        </div>
                                    </th>
                                </tr></thead>
                                <tbody class="addresses monospace">
                                    <tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
                                    <tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
                                    <tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
                                    <tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
                                    <tr><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td><td>&nbsp;</td></tr>
                                </tbody>
                            </table>
                        </div>
                    </div>
                    <div id="csv" class="tab-pane">
                        <div class="col-md-12">
                            <textarea class="csv form-control" rows="25" readonly="readonly" autocomplete="off" autocorrect="off" autocapitalize="none" spellcheck="false"></textarea>
                        </div>
                    </div>
                </div>
            </div>
            <span>Show</span>
            <input type="number" class="rows-to-add" value="20">
            <button class="more">more rows</button>
            <span>starting from index</span>
            <input type="number" class="more-rows-start-index">
            <span>(leave blank to generate from next index)</span>

            <hr>

            <div class="row">
                <div class="col-md-12">
                    <h2>More info</h2>
                    <h3>BIP39 <span class="small">Mnemonic code for generating deterministic keys</span></h3>
                    <p>
                        Read more at the
                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0039.mediawiki">official BIP39 spec</a>
                    </p>
                    <h3>BIP32 <span class="small">Hierarchical Deterministic Wallets</span></h3>
                    <p>
                        Read more at the
                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki" target="_blank">official BIP32 spec</a>
                    </p>
                    <p>
                        See the demo at
                        <a href="http://bip32.org/" target="_blank">bip32.org</a>
                    </p>
                    <h3>BIP44 <span class="small">Multi-Account Hierarchy for Deterministic Wallets</span></h3>
                    <p>
                        Read more at the
                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0044.mediawiki" target="_blank">official BIP44 spec</a>
                    </p>
                    <h3>BIP49 <span class="small">Derivation scheme for P2WPKH-nested-in-P2SH based accounts</span></h3>
                    <p>
                        Read more at the
                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0049.mediawiki" target="_blank">official BIP49 spec</a>
                    </p>
                    <h3>BIP85 <span class="small">Deterministic Entropy From BIP32 Keychains</span></h3>
                    <p>
                        Read more at the
                        <a href="https://github.com/bitcoin/bips/blob/master/bip-0085.mediawiki" target="_blank">official BIP85 spec</a>
                    </p>
                    <h3 id="entropy-notes">Entropy</h3>
                    <p>
                        <span>Entropy values should not include the BIP39 checksum. This is automatically added by the tool.</span>
                    </p>
                    <p>
                        <span>
                            Entropy values must be sourced from a
                            <a href="https://en.wikipedia.org/wiki/Random_number_generation" target="_blank">strong source of randomness</a>.
                        </span>
                        <span>This means flipping a fair coin, rolling a fair dice, noise measurements etc.</span>
                        <span>
                            Do <strong>NOT</strong> use phrases from books, lyrics from songs, your birthday or street address,
                            keyboard mashing, or anything you <i>think</i> is random, because chances are overwhelming it isn't
                            random enough for the needs of this tool.
                        </span>
                    </p>
                    <p>
                        <strong><span>Do not store entropy.</span></strong>
                    </p>
                    <p>
                        <span>Storing entropy (such as keeping a deck of cards in a specific shuffled order) is unreliable compared to storing a mnemonic.</span>
                        <span>Instead of storing entropy, store the mnemonic generated from the entropy.</span>
                        <span><a href="https://en.wikipedia.org/wiki/Steganography#Physical" target="_blank">Steganography</a> may be beneficial when storing the mnemonic.</span>
                    </p>
                    <p>
                        <span>
                            The random mnemonic generator on this page uses a
                            <a href="https://developer.mozilla.org/en-US/docs/Web/API/RandomSource/getRandomValues" target="_blank">cryptographically secure random number generator</a>.
                        </span>
                        <span>The built in random generator can generally be trusted more than your own intuition about randomness.</span>
                        <span>If cryptographic randomness isn't 
available in your browser, this page will show a warning and the 
generate button will not work.</span>
                        <span>In that case you might choose to use your own source of entropy.</span>
                    </p>
                    <p>
                        <a href="https://bitcointalk.org/index.php?topic=311000.msg3345309#msg3345309" target="_blank">You are not a good source of entropy.</a>
                    </p>
                    <p>
                        <span>Card entropy has been implemented assuming cards are replaced, not drawn one after another.</span>
                        <span>A full deck with replacement generates 232
 bits of entropy (21 words). A full deck without replacement generates 
225 bits of entropy (21 words).</span>
                        <span>Card entropy changed significantly from v0.4.3 to v0.5.0. The old version can be accessed at
                            <a href="https://github.com/iancoleman/bip39/releases/tag/0.4.3">
                                https://github.com/iancoleman/bip39/releases/tag/0.4.3
                            </a>
                            or
                            <a href="https://web.archive.org/web/20201018232020/https://iancoleman.io/bip39/">
                                https://web.archive.org/web/20201018232020/https://iancoleman.io/bip39/
                            </a>
                        </span>
                    </p>
                    <h3 id="PBKDF2-notes">PBKDF2</h3>
                    <p><a href="https://learnmeabitcoin.com/technical/mnemonic#pbkdf2---password-based-key-derivation-function-2" target="_blank">What is PBKDF2 (Password Based Key Derivation Function 2) ?</a></p>
                    <p><span>Please refer to this <a href="https://en.wikipedia.org/wiki/PBKDF2" target="_blank">wikipedia article</a> for more detail.
                    <span>Mail about PBKDF2 security <a href="https://lists.linuxfoundation.org/pipermail/bitcoin-dev/2016-July/012902.html" target="_blank">here</a>.</span></span></p>
                    <p>Wallet software that implement BIP39 only use 
2048 iterations as a norm. Increasing this parameter will increase 
security against brute force attack, but you will need to store this new
 parameter. However, as long as you back up your BIP39 seed there will 
not be risk to lost your fund. To access them with custom PBKDF2 
iterations, use this file (or <a href="https://stuff.birkenstab.de/pbkdf2/" target="_blank">other</a>) to compute your targeted BIP39 seed.</p>
                    <p>Using less than 2048 PBKDF2 iterations is insecure without strong optional BIP39 Passphrase.</p>
                    <h3>License</h3>
                    <p>
                    <span>Please refer to <a href="https://github.com/iancoleman/bip39/blob/master/LICENSE" target="_blank">the software license</a> for more detail.
                    </span>
                    </p>
                    <p>The software is provided "as is", without 
warranty of any kind, express or implied, including but not limited to 
the warranties of merchantability, fitness for a particular purpose and 
noninfringement. In no event shall the authors or copyright holders be 
liable for any claim, damages or other liability, whether in an action 
of contract, tort or otherwise, arising from, out of or in connection 
with the software or the use or other dealings in the software.</p>
                </div>
            </div>

            <hr>

            <div class="row">
                <div class="col-md-12">
                    <h2>Alternative Tools</h2>
                    <p>This tool is interoperable with any BIP39 wallet.</p>
                    <p>Some similar tools to this one (ie not consumer wallets) are</p>
                    <p>
                        <a href="https://bip32jp.github.io/english/">
                            https://bip32jp.github.io/english/
                        </a>
                    </p>
                </div>
            </div>

            <hr>

            <div class="row">
                <div class="col-md-12">

                    <h2>Offline Usage</h2>

                    <p>
                    You can use this tool without having to be online.
                    </p>
                    <p>
                    In your browser, select file save-as, and save this page
                    as a file.
                    </p>
                    <p>
                    Double-click that file to open it in a browser
                    on any offline computer.
                    </p>
                    <p>
                    <span>Alternatively, download the file from the latest GitHub release</span>
                    -
                    <a href="https://github.com/iancoleman/bip39/releases/latest/">https://github.com/iancoleman/bip39/releases/latest/</a>
                    </p>

                </div>
            </div>

            <hr>

            <div class="row">
                <div class="col-md-12">

                    <h2>This project is 100% open-source code</h2>

                    <p>
                        <span>Get the source code from the repository</span>
                        -
                        <a href="https://github.com/iancoleman/bip39" target="_blank">
                            https://github.com/iancoleman/bip39
                        </a>
                    </p>

                    <h3>Libraries</h3>

                    <p>
                        <span>BitcoinJS - </span>
                        <a href="https://github.com/bitcoinjs/bitcoinjs-lib" target="_blank">
                            https://github.com/bitcoinjs/bitcoinjs-lib
                        </a>
                    </p>

                    <p>
                        <span>jsBIP39 - </span>
                        <a href="https://github.com/iancoleman/jsbip39" target="_blank">
                            https://github.com/iancoleman/jsbip39
                        </a>
                    </p>

                    <p>
                        <span>sjcl - </span>
                        <a href="https://github.com/bitwiseshiftleft/sjcl" target="_blank">
                            https://github.com/bitwiseshiftleft/sjcl
                        </a>
                    </p>

                    <p>
                        <span>jQuery - </span>
                        <a href="https://jquery.com/" target="_blank">
                            https://jquery.com/
                        </a>
                    </p>

                    <p>
                        <span>Twitter Bootstrap - </span>
                        <a href="http://getbootstrap.com/" target="_blank">
                            http://getbootstrap.com/
                        </a>
                    </p>

                </div>
            </div>

        </div>

        <div class="qr-container hidden">
            <div class="qr-hint bg-primary hidden">Click field to hide QR</div>
            <div class="qr-hint bg-primary">Click field to show QR</div>
            <div class="qr-hider hidden">
                <div class="qr-image"></div>
                <div class="qr-warning bg-primary">Caution: Scanner may keep history</div>
            </div>
        </div>

        <div class="feedback-container">
            <div class="feedback" style="display: none;"></div>
        </div>

        <script type="text/template" id="address-row-template">
            <tr>
                <td class="index"><span></span></td>
                <td class="address"><span data-show-qr></span></td>
                <td class="pubkey"><span data-show-qr></span></td>
                <td class="privkey private-data"><span data-show-qr></span></td>
            </tr>
        </script>


<script src="jquery_3.2.1.js"></script>
<script src="bootstrap_3.4.1.js"></script>
<script src="main.js"></script>





<script>
libs.bitcoin.networks.shadow = {
  messagePrefix: 'unused',
  bip32: {
    public: 0xEE80286A,
    private: 0xEE8031E8
  },
  pubKeyHash: 0x3f,
  scriptHash: 0x7d,
  wif: 0xbf
};

libs.bitcoin.networks.shadowtn = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x76C0FDFB,
    private: 0x76C1077A
  },
  pubKeyHash: 0x7f,
  scriptHash: 0xc4,
  wif: 0xff
};

libs.bitcoin.networks.clam = {
  messagePrefix: 'unused',
  bip32: {
    public: 0xa8c26d64,
    private: 0xa8c17826
  },
  pubKeyHash: 0x89,
  scriptHash: 0x0D,
  wif: 0x85
};

libs.bitcoin.networks.crown = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif: 0x80,
  toNewAddress: function(oldAddress)
  {
    var ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'
    var b58 =  libs.basex(ALPHABET);

    var addrBytes = b58.decode(oldAddress);

    var hash160 = libs.buffer.Buffer.from(new Uint16Array(23));
    hash160[0]= 0x01; //C
    hash160[1]= 0x75; //R
    hash160[2]= 0x07; //W
    addrBytes.copy(hash160, 3, 1, 21);

    var checksum = libs.bitcoin.crypto.hash256(hash160).subarray(0, 4);
    var binaryAddr = libs.buffer.Buffer.from(new Uint16Array(27));
    binaryAddr.set(hash160,0);
    checksum.copy(binaryAddr, 23, 0, 4);
    var newAddress = b58.encode(binaryAddr);
    return newAddress;
  }
};

libs.bitcoin.networks.dash = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x4c,
  scriptHash: 0x10,
  wif: 0xcc
};

libs.bitcoin.networks.maza = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x32,
  scriptHash: 0x09,
  wif: 0xe0
};

libs.bitcoin.networks.dashtn = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394
  },
  pubKeyHash: 0x8c,
  scriptHash: 0x13,
  wif: 0xef
};

libs.bitcoin.networks.game = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x26,
  scriptHash: 0x05,
  wif: 0xa6
};

libs.bitcoin.networks.namecoin = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x34,
  scriptHash: 0x0D,
  wif: 0xb4
};

libs.bitcoin.networks.peercoin = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x37,
  scriptHash: 0x75,
  wif: 0xb7
};

libs.bitcoin.networks.axe = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x37,
  scriptHash: 0x10, // TODO set this correctly
  wif: 0xcc
};

libs.bitcoin.networks.scribe = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4
  },
  pubKeyHash: 0x3c,
  scriptHash: 0x7d,
  wif: 0x6e
};

libs.bitcoin.networks.slimcoin = {
  messagePrefix: 'unused',
  bip32: {
    public: 0xef6adf10,
    private: 0xef69ea80
  },
  pubKeyHash: 0x3f,
  scriptHash: 0x7d,
  wif: 0x46
};

libs.bitcoin.networks.slimcointn = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x043587CF,
    private: 0x04358394
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0x57
};

libs.bitcoin.networks.dogecoin = {
  messagePrefix: '\x19Dogecoin Signed Message:\n',
  bip32: {
    public: 0x02facafd,
    private: 0x02fac398
  },
  pubKeyHash: 0x1e,
  scriptHash: 0x16,
  wif: 0x9e
};

libs.bitcoin.networks.dogecointestnet = {
  messagePrefix: '\x19Dogecoin Signed Message:\n',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394
  },
  pubKeyHash: 0x71,
  scriptHash: 0xc4,
  wif: 0xf1
};

libs.bitcoin.networks.denarius = {
  messagePrefix: '\x19Denarius Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x1e,
  scriptHash: 0x5a,
  wif: 0x9e
};

libs.bitcoin.networks.neblio = {
  messagePrefix: '\x18Neblio Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x35,
  scriptHash: 0x70,
  wif: 0xb5
};

libs.bitcoin.networks.viacoin = {
  messagePrefix: '\x18Viacoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x47,
  scriptHash: 0x21,
  wif: 0xc7
};

libs.bitcoin.networks.viacointestnet = {
  messagePrefix: '\x18Viacoin Signed Message:\n',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394
  },
  pubKeyHash: 0x7f,
  scriptHash: 0xc4,
  wif: 0xff
};

libs.bitcoin.networks.gamerscoin = {
  messagePrefix: '\x19Gamerscoin Signed Message:\n',
  bip32: {
    public: 0x019da462,
    private: 0x019d9cfe
  },
  pubKeyHash: 0x26,
  scriptHash: 0x05,
  wif: 0xA6
};

libs.bitcoin.networks.jumbucks = {
  messagePrefix: '\x19Jumbucks Signed Message:\n',
  bip32: {
    public: 0x037a689a,
    private: 0x037a6460
  },
  pubKeyHash: 0x2b,
  scriptHash: 0x05,
  wif: 0xab
};

libs.bitcoin.networks.zetacoin = {
  messagePrefix: '\x18Zetacoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x50,
  scriptHash: 0x09,
  wif: 0xe0
};

libs.bitcoin.networks.myriadcoin = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x32,
  scriptHash: 0x09,
  wif: 0xb2
};

libs.bitcoin.networks.bolivarcoin = {
  messagePrefix: 'Bolivarcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x55,
  scriptHash: 0x05,
  wif: 0xD5
};

libs.bitcoin.networks.onixcoin = {
    messagePrefix: 'ONIX Signed Message:\n',
    bip32: {
      public: 0x0488b21e,
      private: 0x0488ade4
    },
    pubKeyHash: 0x4B,
    scriptHash: 0x05,
    wif: 0xCB
};


libs.bitcoin.networks.lkrcoin = {
    messagePrefix: '\x18LKRcoin Signed Message:\n',
    bip32: {
      public: 0x0488b21e,
      private: 0x0488ade4,
    },
    pubKeyHash: 0x30,
    scriptHash: 0x55,
    wif: 0xB0
};

libs.bitcoin.networks.pivx = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x022d2533,
    private: 0x0221312b
  },
  pubKeyHash: 0x1e,
  scriptHash: 0x0d,
  wif: 0xd4
};

libs.bitcoin.networks.pivxtestnet = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x3a8061a0,
    private: 0x3a805837
  },
  pubKeyHash: 0x8b,
  scriptHash: 0x13,
  wif: 0xef
};

libs.bitcoin.networks.fix = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x022d2533,
    private: 0x0221312b
  },
  pubKeyHash: 0x23,
  scriptHash: 0x5F,
  wif: 0x3C
};

libs.bitcoin.networks.fixtestnet = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x3a8061a0,
    private: 0x3a805837
  },
  pubKeyHash: 0x4c,
  scriptHash: 0x89,
  wif: 0xED
};

libs.bitcoin.networks.fujicoin = {
  messagePrefix: '\x19FujiCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x24,
  scriptHash: 0x10,
  wif: 0xa4
};

libs.bitcoin.networks.nubits = {
  messagePrefix: '\x18Nu Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x19,
  scriptHash: 0x1a,
  wif: 0x96,
};

libs.bitcoin.networks.bgold = {
  messagePrefix: '\x1DBitcoin Gold Signed Message:\n',
    bip32: {
      public: 0x0488b21e,
      private: 0x0488ade4
    },
    pubKeyHash: 38,
    scriptHash: 23,
    wif: 128
};

libs.bitcoin.networks.monacoin = {
    messagePrefix: '\x18Monacoin Signed Message:\n',
    bip32: {
      public: 0x0488b21e,
      private: 0x0488ade4
    },
    pubKeyHash: 0x32,
    scriptHash: 0x37,
    wif: 0xb0
};

libs.bitcoin.networks.litecoinXprv = {
    messagePrefix: '\x19Litecoin Signed Message:\n',
    bip32: {
      public: 0x0488b21e,
      private: 0x0488ade4,
    },
    pubKeyHash: 0x30,
    scriptHash: 0x32,
    wif: 0xb0
};

libs.bitcoin.networks.komodo = {
  messagePrefix: '\x18Komodo Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4
  },
  pubKeyHash: 0x3c,
  scriptHash: 0x55,
  wif: 0xbc
};

libs.bitcoin.networks.blackcoin = {
  messagePrefix: '\x18BlackCoin Signed Message:\n',
  bip32: {
    public: 0x02CFBEDE,
    private: 0x02CFBF60
  },
  pubKeyHash: 0x19,
  scriptHash: 0x55,
  wif: 0x99
};

libs.bitcoin.networks.beetlecoin = {
  messagePrefix: '\x19Beetlecoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x1A,
  scriptHash: 0x55,
  wif: 0x99,
};


libs.bitcoin.networks.adcoin = {
  messagePrefix: '\x18AdCoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x17,
  scriptHash: 0x05,
  wif: 0xb0,
};

libs.bitcoin.networks.asiacoin = {
  messagePrefix: '\x18AsiaCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x17,
  scriptHash: 0x08,
  wif: 0x97,
};

libs.bitcoin.networks.auroracoin = {
  messagePrefix: '\x18AuroraCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x17,
  scriptHash: 0x05,
  wif: 0x97,
};

libs.bitcoin.networks.bata = {
  messagePrefix: '\x18Bata Signed Message:\n',
  bip32: {
    public: 0xA40C86FA,
    private: 0xA40B91BD,
  },
  pubKeyHash: 0x19,
  scriptHash: 0x05,
  wif: 0xa4,
};

libs.bitcoin.networks.belacoin = {
  messagePrefix: '\x18BelaCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x19,
  scriptHash: 0x05,
  wif: 0x99,
};

libs.bitcoin.networks.atom = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x17,
  scriptHash: 0x0a,
  wif: 0x80,
};

libs.bitcoin.networks.bitcoinplus = {
  messagePrefix: '\x18BitcoinPlus Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x19,
  scriptHash: 0x08,
  wif: 0x99,
};

libs.bitcoin.networks.bitcloud = {
  messagePrefix: '\x18BitCloud Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x19,
  scriptHash: 0x05,
  wif: 0x99,
};

libs.bitcoin.networks.bitcore = {
  messagePrefix: '\x18BitCore Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x03,
  scriptHash: 0x7D,
  wif: 0x80,
};

libs.bitcoin.networks.bitsend = {
  messagePrefix: '\x18Bitsend Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x66,
  scriptHash: 0x05,
  wif: 0xcc,
};

libs.bitcoin.networks.britcoin = {
  messagePrefix: '\x18BritCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x19,
  scriptHash: 0x55,
  wif: 0x99,
};

libs.bitcoin.networks.canadaecoin = {
  messagePrefix: '\x18Canada eCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x1c,
  scriptHash: 0x05,
  wif: 0x9c,
};

libs.bitcoin.networks.cannacoin = {
  messagePrefix: '\x18Cannacoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x1c,
  scriptHash: 0x05,
  wif: 0x9c,
};

libs.bitcoin.networks.cranepay = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 28,
  scriptHash: 10,
  wif: 123,
};

libs.bitcoin.networks.cryptoescudo = {
  messagePrefix: '\x18Cryptoescudo Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x1c,
  scriptHash: 0x05,
  wif: 0x9c,
};

libs.bitcoin.networks.clubcoin = {
  messagePrefix: '\x18ClubCoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x1c,
  scriptHash: 0x55,
  wif: 0x99,
};

libs.bitcoin.networks.compcoin = {
  messagePrefix: '\x18CompCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x1c,
  scriptHash: 0x55,
  wif: 0x9c,
};

libs.bitcoin.networks.crave = {
  messagePrefix: '\x18DarkNet Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x46,
  scriptHash: 0x55,
  wif: 0x99,
};

libs.bitcoin.networks.defcoin = {
  messagePrefix: '\x18defcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x1e,
  scriptHash: 0x05,
  wif: 0x9e,
};

libs.bitcoin.networks.diamond = {
  messagePrefix: '\x18Diamond Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x5a,
  scriptHash: 0x08,
  wif: 0xda,
};

libs.bitcoin.networks.digibyte = {
  messagePrefix: '\x19DigiByte Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x1e,
  scriptHash: 0x05,
  wif: 0x80,
};

libs.bitcoin.networks.digitalcoin = {
  messagePrefix: '\x18Digitalcoin Signed Message:\n',
  bip32: {
    public: 0x9e0488B2,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x1e,
  scriptHash: 0x05,
  wif: 0x9e,
};

libs.bitcoin.networks.divi = {
  messagePrefix: '\x19Divi Signed Message:\n',
  bip32: {
    public: 0x022d2533,
    private: 0x0221312b,
  },
  pubKeyHash: 0x1e,
  scriptHash: 0x0d,
  wif: 0xd4,
};

libs.bitcoin.networks.divitestnet = {
  messagePrefix: '\x19Divi Signed Message:\n',
  bip32: {
    public: 0x3a8061a0,
    private: 0x3a805837,
  },
  pubKeyHash: 0x8b,
  scriptHash: 0x13,
  wif: 0xef,
};

libs.bitcoin.networks.ecoin = {
  messagePrefix: '\x18eCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x5c,
  scriptHash: 0x14,
  wif: 0xdc,
};

libs.bitcoin.networks.edrcoin = {
  messagePrefix: '\x18EDRcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x5d,
  scriptHash: 0x1c,
  wif: 0xdd,
};

libs.bitcoin.networks.egulden = {
  messagePrefix: '\x18Egulden Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x30,
  scriptHash: 0x05,
  wif: 0xb0,
};

libs.bitcoin.networks.einsteinium = {
  messagePrefix: '\x18Einsteinium Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x21,
  scriptHash: 0x05,
  wif: 0xa1,
};

libs.bitcoin.networks.europecoin = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x21,
  scriptHash: 0x05,
  wif: 0xa8,
};

libs.bitcoin.networks.exclusivecoin = {
  messagePrefix: '\x18ExclusiveCoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x21,
  scriptHash: 0x89,
  wif: 0xa1,
};

libs.bitcoin.networks.feathercoin = {
  messagePrefix: '\x18Feathercoin Signed Message:\n',
  bip32: {
    public: 0x0488BC26,
    private: 0x0488DAEE,
  },
  pubKeyHash: 0x0e,
  scriptHash: 0x05,
  wif: 0x8e,
};

libs.bitcoin.networks.firo = {
  messagePrefix: '\x18Firo Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x52,
  scriptHash: 0x07,
  wif: 0xd2,
};

libs.bitcoin.networks.zcoin = {
  messagePrefix: '\x18Zcoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x52,
  scriptHash: 0x07,
  wif: 0xd2,
};

libs.bitcoin.networks.firstcoin = {
  messagePrefix: '\x18FirstCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x23,
  scriptHash: 0x05,
  wif: 0xa3,
};

libs.bitcoin.networks.flashcoin = {
  messagePrefix: '\x18Flashcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x44,
  scriptHash: 0x82,
  wif: 0xc4,
};

libs.bitcoin.networks.gcr = {
  messagePrefix: '\x18GCR Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x26,
  scriptHash: 0x61,
  wif: 0x9a,
};

libs.bitcoin.networks.gobyte = {
  messagePrefix: '\x18DarkCoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x26,
  scriptHash: 0x0a,
  wif: 0xc6,
};

libs.bitcoin.networks.gridcoin = {
  messagePrefix: '\x18Gridcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x3e,
  scriptHash: 0x55,
  wif: 0xbe,
};

libs.bitcoin.networks.groestlcoin = {
  messagePrefix: '\x19GroestlCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 36,
  scriptHash: 5,
  wif: 128,
}

libs.bitcoin.networks.groestlcointestnet = {
  messagePrefix: '\x19GroestlCoin Signed Message:\n',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
}

libs.bitcoin.networks.gulden = {
  messagePrefix: '\x18Guldencoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x26,
  scriptHash: 0x62,
  wif: 0x62,
};

libs.bitcoin.networks.helleniccoin = {
  messagePrefix: '\x18helleniccoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x30,
  scriptHash: 0x05,
  wif: 0xb0,
};

libs.bitcoin.networks.hempcoin = {
  messagePrefix: '\x18Hempcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x28,
  scriptHash: 0x08,
  wif: 0xa8,
};

libs.bitcoin.networks.insane = {
  messagePrefix: '\x18INSaNe Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x66,
  scriptHash: 0x39,
  wif: 0x37,
};

libs.bitcoin.networks.iop = {
  messagePrefix: '\x18IoP Signed Message:\n',
  bip32: {
    public: 0x2780915F,
    private: 0xAE3416F6,
  },
  pubKeyHash: 0x75,
  scriptHash: 0xae,
  wif: 0x31,
};

libs.bitcoin.networks.ixcoin = {
  messagePrefix: '\x18Ixcoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x8a,
  scriptHash: 0x05,
  wif: 0x80,
};

libs.bitcoin.networks.kobocoin = {
  messagePrefix: '\x18Kobocoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x23,
  scriptHash: 0x1c,
  wif: 0xa3,
};

libs.bitcoin.networks.landcoin = {
  messagePrefix: '\x18Landcoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x30,
  scriptHash: 0x7a,
  wif: 0xb0,
};

libs.bitcoin.networks.lbry = {
  messagePrefix: '\x18LBRYcrd Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x55,
  scriptHash: 0x7a,
  wif: 0x1c,
};

libs.bitcoin.networks.linx = {
  messagePrefix: '\x18LinX Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x4b,
  scriptHash: 0x05,
  wif: 0xcb,
};


libs.bitcoin.networks.litecointestnet = {
  messagePrefix: '\x18Litecoin Signed Message:\n',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};
libs.bitcoin.networks.litecoincash = {
  messagePrefix: '\x18Litecoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x1c,
  scriptHash: 0x05,
  wif: 0xb0,
};

libs.bitcoin.networks.lynx = {
  messagePrefix: '\x18Lynx Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x2d,
  scriptHash: 0x32,
  wif: 0xad,
};

libs.bitcoin.networks.megacoin = {
  messagePrefix: '\x18Megacoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x32,
  scriptHash: 0x05,
  wif: 0xB2,
};

libs.bitcoin.networks.minexcoin = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x4b,
  scriptHash: 0x05,
  wif: 0x80,
};

libs.bitcoin.networks.navcoin = {
  messagePrefix: '\x18Navcoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x35,
  scriptHash: 0x55,
  wif: 0x96,
};

libs.bitcoin.networks.neoscoin = {
  messagePrefix: '\x18NeosCoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x35,
  scriptHash: 0x05,
  wif: 0xb1,
};

libs.bitcoin.networks.nix = {
  messagePrefix: '\x18Nix Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x26,
  scriptHash: 0x35,
  wif: 0x80,
};

libs.bitcoin.networks.neurocoin = {
  messagePrefix: '\x18PPCoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x35,
  scriptHash: 0x75,
  wif: 0xb5,
};

libs.bitcoin.networks.newyorkc = {
  messagePrefix: '\x18newyorkc Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x3c,
  scriptHash: 0x16,
  wif: 0xbc,
};

libs.bitcoin.networks.novacoin = {
  messagePrefix: '\x18NovaCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x08,
  scriptHash: 0x14,
  wif: 0x88,
};

libs.bitcoin.networks.nushares = {
  messagePrefix: '\x18Nu Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x3f,
  scriptHash: 0x40,
  wif: 0x95,
};

libs.bitcoin.networks.okcash = {
  messagePrefix: '\x18OKCash Signed Message:\n',
  bip32: {
    public: 0x03CC23D7,
    private: 0x03CC1C73,
  },
  pubKeyHash: 0x37,
  scriptHash: 0x1c,
  wif: 0x03,
};

libs.bitcoin.networks.omnicore = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif: 0x80,
};

libs.bitcoin.networks.pesobit = {
  messagePrefix: '\x18Pesobit Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x37,
  scriptHash: 0x55,
  wif: 0xb7,
};

libs.bitcoin.networks.pinkcoin = {
  messagePrefix: '\x18Pinkcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x03,
  scriptHash: 0x1c,
  wif: 0x83,
};

libs.bitcoin.networks.poswcoin = {
  messagePrefix: '\x18Poswcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x37,
  scriptHash: 0x55,
  wif: 0xb7,
};

libs.bitcoin.networks.potcoin = {
  messagePrefix: '\x18Potcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x37,
  scriptHash: 0x05,
  wif: 0xb7,
};

libs.bitcoin.networks.putincoin = {
  messagePrefix: '\x18PutinCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x37,
  scriptHash: 0x14,
  wif: 0xb7,
};

libs.bitcoin.networks.ravencoin = {
  messagePrefix: '\x16Raven Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x3c,
  scriptHash: 0x7a,
  wif: 0x80,
};

libs.bitcoin.networks.reddcoin = {
  messagePrefix: '\x18Reddcoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x3d,
  scriptHash: 0x05,
  wif: 0xbd,
};

libs.bitcoin.networks.revolutionvr = {
  messagePrefix: '\x18Voxels Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x46,
  scriptHash: 0x05,
  wif: 0xc6,
};

libs.bitcoin.networks.ritocoin = {
  messagePrefix: '\x15Rito Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x19,
  scriptHash: 0x69,
  wif: 0x8b,
};

libs.bitcoin.networks.rsk = {
  messagePrefix: '\x18RSK Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  // TODO defaulting to Bitcoin value, check this
  pubKeyHash: 0x00,
  // TODO defaulting to Bitcoin value, check this
  scriptHash: 0x05,
  // TODO defaulting to Bitcoin value, check this
  wif: 0x80
};

libs.bitcoin.networks.rsktestnet = {
  messagePrefix: '\x18RSK Testnet Signed Message:\n',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef
};

libs.bitcoin.networks.rubycoin = {
  messagePrefix: '\x18Rubycoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x3c,
  scriptHash: 0x55,
  wif: 0xbc,
};

libs.bitcoin.networks.safecoin = {
  messagePrefix: '\x18Safecoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x3d,
  scriptHash: 0x56,
  wif: 0xbd,
};

libs.bitcoin.networks.salus = {
messagePrefix: '\x18Salus Signed Message:\n',
bip32: {
  public: 0x0488B21E,
  private: 0x0488ADE4,
},
pubKeyHash: 0x3f,
scriptHash: 0xc4,
wif: 0xbf,
};

libs.bitcoin.networks.smileycoin = {
  messagePrefix: '\x18Smileycoin Signed Message:\n',
  bip32: {
    public: 0x1E562D9A,
    private: 0x1E5631BC,
  },
  pubKeyHash: 0x19,
  scriptHash: 0x05,
  wif: 0x05,
};

libs.bitcoin.networks.solarcoin = {
  messagePrefix: '\x18SolarCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x12,
  scriptHash: 0x05,
  wif: 0x92,
};

libs.bitcoin.networks.stash = {
  messagePrefix: '\x18Stash Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x4c,
  scriptHash: 0x10,
  wif: 0xcc
};

libs.bitcoin.networks.stashtn = {
  messagePrefix: '\x18Stash Test Signed Message:\n',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394
  },
  pubKeyHash: 0x8c,
  scriptHash: 0x13,
  wif: 0xef
};

libs.bitcoin.networks.stratis = {
  messagePrefix: '\x18Stratis Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x3f,
  scriptHash: 0x7d,
  wif: 0xbf,
};

libs.bitcoin.networks.stratistest = {
  messagePrefix: '\x18Stratis Test Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x41,
  scriptHash: 0x7d,
  wif: 0xbf,
};

libs.bitcoin.networks.syscoin = {
  messagePrefix: '\x18Syscoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x3f,
  scriptHash: 0x05,
  wif: 0x80,
};


libs.bitcoin.networks.toa = {
  messagePrefix: '\x18TOA Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x41,
  scriptHash: 0x17,
  wif: 0xc1,
};

libs.bitcoin.networks.twins = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x022d2533,
    private: 0x0221312b
  },
  pubKeyHash: 0x49,
  scriptHash: 0x53,
  wif: 0x42
};

libs.bitcoin.networks.twinstestnet = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x3a8061a0,
    private: 0x3a805837
  },
  pubKeyHash: 0x4c,
  scriptHash: 0x89,
  wif: 0xED
};

libs.bitcoin.networks.ultimatesecurecash = {
  messagePrefix: '\x18UltimateSecureCash Signed Message:\n',
  bip32: {
    public: 0xEE80286A,
    private: 0xEE8031E8,
  },
  pubKeyHash: 0x44,
  scriptHash: 0x7d,
  wif: 0xbf,
};

libs.bitcoin.networks.unobtanium = {
  messagePrefix: '\x18Unobtanium Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x82,
  scriptHash: 0x1e,
  wif: 0xe0,
};

libs.bitcoin.networks.vcash = {
  messagePrefix: '\x18Vcash Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x47,
  scriptHash: 0x08,
  wif: 0xc7,
};

libs.bitcoin.networks.verge = {
  messagePrefix: '\x18VERGE Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x1e,
  scriptHash: 0x21,
  wif: 0x9e,
};

libs.bitcoin.networks.vertcoin = {
  messagePrefix: '\x18Vertcoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x47,
  scriptHash: 0x05,
  wif: 0x80,
};

libs.bitcoin.networks.vivo = {
  messagePrefix: '\x18DarkCoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x46,
  scriptHash: 0x0a,
  wif: 0xc6,
};

libs.bitcoin.networks.vpncoin = {
  messagePrefix: '\x18VpnCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x47,
  scriptHash: 0x05,
  wif: 0xc7,
};

libs.bitcoin.networks.whitecoin = {
  messagePrefix: '\x18Whitecoin Signed Message:\n',
  bip32: {
    public: 0x04887F1E,
    private: 0x048894ED,
  },
  pubKeyHash: 0x49,
  scriptHash: 0x57,
  wif: 0xc9,
};

libs.bitcoin.networks.wincoin = {
  messagePrefix: '\x18WinCoin Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x49,
  scriptHash: 0x1c,
  wif: 0xc9,
};

libs.bitcoin.networks.zcash = {
  messagePrefix: '\x18Zcash Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x1CB8,
  scriptHash: 0x1CBD,
  wif: 0x80,
};

libs.bitcoin.networks.xuez = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x022d2533,
    private: 0x0221312b
  },
  pubKeyHash: 0x4b,
  scriptHash: 0x12,
  wif: 0xd4
};

libs.bitcoin.networks.bitcoinprivate = {
  messagePrefix: '\x18BitcoinPrivate Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x1325,
  scriptHash: 0x13AF,
  wif: 0x80,
};

libs.bitcoin.networks.bitcoinprivatetestnet = {
  messagePrefix: '\x18BitcoinPrivate Signed Message:\n',
  bip32: {
    public: 0x043587CF,
    private: 0x04358394,
  },
  pubKeyHash: 0x1957,
  scriptHash: 0x19E0,
  wif: 0xEF,
};

libs.bitcoin.networks.bitcoinz = {
  messagePrefix: '\x18BitcoinZ Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x1CB8,
  scriptHash: 0x1CBD,
  wif: 0x80,
};

libs.bitcoin.networks.hush = {
  messagePrefix: '\x18Hush Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x1CB8,
  scriptHash: 0x1CBD,
  wif: 0x80,
};

libs.bitcoin.networks.hush3 = {
  messagePrefix: '\x18Hush Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x3C,
  scriptHash: 0x55,
  wif: 0xBC,
};

libs.bitcoin.networks.zoobc = {
  messagePrefix: '\x18ZooBC Signed Message:\n',
  bech32: 'bc',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4,
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif: 0x80,
};

libs.bitcoin.networks.zclassic = {
  messagePrefix: '\x18Zcash Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x1CB8,
  scriptHash: 0x1CBD,
  wif: 0x80,
};

libs.bitcoin.networks.zencash = {
  messagePrefix: '\x18Zcash Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x2089,
  scriptHash: 0x2096,
  wif: 0x80,
};

libs.bitcoin.networks.energi = {
  messagePrefix: 'DarkCoin Signed Message:\n',
  bip32: {
    public: 0x03B8C856,
    private: 0xD7DC6E9F,
  },
  pubKeyHash: 0x21,
  scriptHash: 0x35,
  wif: 0x6a,
};

libs.bitcoin.networks.exchangecoin = {
  messagePrefix: 'ExchangeCoin Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x21B9,
  scriptHash: 0x34AF,
  wif: 0x80,
};

libs.bitcoin.networks.artax = {
  messagePrefix: '\x18Artax Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x17,
  scriptHash: 0x1CBD,
  wif: 0x97,
};

libs.bitcoin.networks.bitcoingreen = {
  messagePrefix: '\x18BitcoinGreen Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x26,
  scriptHash: 0x1CBD,
  wif:  0x2E,
};

libs.bitcoin.networks.anon = {
	messagePrefix: '\x18ANON Signed Message:\n',
	bip32: {
		public: 0x0488b21e,
		private: 0x0488ade4
	},
	pubKeyHash: 0x0582,
	scriptHash: 0x5389,
	wif: 0x80
};

libs.bitcoin.networks.projectcoin = {
  messagePrefix: '\x18ProjectCoin Signed Message:\n',
  bip32: {
    public: 0x022D2533,
    private: 0x0221312B,
  },
  pubKeyHash: 0x37,
  scriptHash: 0x08,
  wif:  0x75,
};

libs.bitcoin.networks.phore = {
  messagePrefix: '\x18Phore Signed Message:\n',
  bip32: {
    public: 0x022D2533,
    private: 0x0221312B,
  },
  pubKeyHash: 0x37,
  scriptHash: 0x0D,
  wif:  0xD4,
};

libs.bitcoin.networks.blocknode = {
  messagePrefix: '\x18Blocknode Signed Message:\n',
  bip32: {
	public: 0x0488b21e,
	private: 0x0488ade4
  },
  pubKeyHash: 0x19,
  scriptHash: 0x3F,
  wif:  0x4b,
};

libs.bitcoin.networks.blocknode_testnet = {
  messagePrefix: '\x18Blocknode Testnet Signed Message:\n',
  bip32: {
	public: 0x043587cf,
	private: 0x04358394
  },
  pubKeyHash: 0x55,
  scriptHash: 0x7d,
  wif:  0x89,
};

libs.bitcoin.networks.litecoinz = {
  messagePrefix: '\x18LitecoinZ Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE3,
  },
  pubKeyHash: 0x0AB3,
  scriptHash: 0x0AB8,
  wif:  0x80,
};

libs.bitcoin.networks.blockstamp = {
  messagePrefix: '\x18BlockStamp Signed Message:\n',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif:  0x80,
};

libs.bitcoin.networks.deeponion = {
    messagePrefix: 'x18DeepOnion Signed Message:\n',
    bip32: {
      public: 0x0488B21E,
      private: 0x0488ADE4,
    },
    pubKeyHash: 0x1F,
    scriptHash: 0x4E,
    wif: 0x9F,
};


libs.bitcoin.networks.cpuchain = {
    messagePrefix: 'x18CPUchain Signed Message:\n',
    bip32: {
      public: 0x0488B21E,
      private: 0x0488ADE4,
    },
    pubKeyHash: 0x1C,
    scriptHash: 0x1E,
    wif: 0x80,
};

libs.bitcoin.networks.wagerr = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x022d2533,
    private: 0x0221312b
  },
  pubKeyHash: 0x49,
  scriptHash: 0x3f,
  wif: 0xc7
};

libs.bitcoin.networks.bitcoinsv = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x00,
  scriptHash: 0x05,
  wif: 0x80
};

libs.bitcoin.networks.monkeyproject = {
  messagePrefix: 'Monkey Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488dde4
  },
  pubKeyHash: 0x33,
  scriptHash: 0x1c,
  wif: 0x37
};

libs.bitcoin.networks.rapids = {
  messagePrefix: 'DarkNet Signed Message:\n',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x3d,
  scriptHash: 0x06,
  wif: 0x2e
};

libs.bitcoin.networks.aryacoin = {
  messagePrefix: '\x18Aryacoin Signed Message:\n',
  bech32: 'arya',
  bip32: {
    public: 0x0488B21E,
    private: 0x0488ADE4,
  },
  pubKeyHash: 0x17,
  scriptHash: 0x6f,
  wif: 0x97
};

libs.bitcoin.networks.thought = {
  messagePrefix: 'unused',
  bip32: {
    public: 0xFbC6A00D,
    private: 0x5AEBD8C6
  },
  pubKeyHash: 0x07,
  scriptHash: 0x09,
  wif: 0x7B
};

libs.bitcoin.networks.elastos = {
    messagePrefix: 'unused',
    bip32: {
        public: 0x0488B21E,
        private: 0x0488ADE4,
    },
    pubKeyHash: 0x21,
    scriptHash: 0xc4, // TODO set this correctly, same as BTC for now
    wif: 0xef // TODO set this correctly, same as BTC for now
};

libs.bitcoin.networks.sugarchain = {
    messagePrefix: '\x18Sugarchain Signed Message:\n',
    bip32: {
        public: 0x0488B21E,
        private: 0x0488ADE4,
    },
    pubKeyHash: 0x3f,
    scriptHash: 0x7d,
    wif: 0x80
};

libs.bitcoin.networks.sugarchaintestnet = {
    messagePrefix: '\x18Sugarchain Signed Message:\n',
    bip32: {
        public: 0x045f1cf6,
        private: 0x045f18bc,
    },
    pubKeyHash: 0x42,
    scriptHash: 0x80,
    wif: 0xef
};

// https://github.com/libs.bitcoinjs-lib/blob/3f6f5ef97a1ee1b8337865209282c0095e22b2e7/src/networks.js
libs.bitcoin.networks.regtest = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'bcrt',
  bip32: {
    public: 0x043587cf,
    private: 0x04358394,
  },
  pubKeyHash: 0x6f,
  scriptHash: 0xc4,
  wif: 0xef,
};

libs.bitcoin.networks.argoneum = {
  messagePrefix: 'unused',
  bip32: {
    public: 0x0488b21e,
    private: 0x0488ade4
  },
  pubKeyHash: 0x32,
  scriptHash: 0x61,
  wif: 0xbf
};

libs.bitcoin.networks.particl = {
  messagePrefix: '\x18Bitcoin Signed Message:\n',
  bech32: 'pw',
  bip32: {
    public: 0x696e82d1,
    private: 0x8f1daeb8,
  },
  pubKeyHash: 0x38,
  scriptHash: 0x3c,
  wif: 0x6c,
};
</script>


<script>
(function() {

// p2wpkh

libs.bitcoin.networks.bitcoin.p2wpkh = {
    baseNetwork: "bitcoin",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bc',
    bip32: {
        public: 0x04b24746,
        private: 0x04b2430c
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80
};

libs.bitcoin.networks.testnet.p2wpkh = {
    baseNetwork: "testnet",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'tb',
    bip32: {
        public: 0x045f1cf6,
        private: 0x045f18bc
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

libs.bitcoin.networks.regtest.p2wpkh = {
    baseNetwork: "regtest",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bcrt',
    bip32: {
        public: 0x045f1cf6,
        private: 0x045f18bc
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

// p2wpkh in p2sh

libs.bitcoin.networks.bitcoin.p2wpkhInP2sh = {
    baseNetwork: "bitcoin",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bc',
    bip32: {
        public: 0x049d7cb2,
        private: 0x049d7878
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80
};

libs.bitcoin.networks.testnet.p2wpkhInP2sh = {
    baseNetwork: "testnet",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'tb',
    bip32: {
        public: 0x044a5262,
        private: 0x044a4e28
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

libs.bitcoin.networks.regtest.p2wpkhInP2sh = {
    baseNetwork: "regtest",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bcrt',
    bip32: {
        public: 0x044a5262,
        private: 0x044a4e28
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

// p2wsh

libs.bitcoin.networks.bitcoin.p2wsh = {
    baseNetwork: "bitcoin",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bc',
    bip32: {
        public: 0x02aa7ed3,
        private: 0x02aa7a99
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80
};

libs.bitcoin.networks.testnet.p2wsh = {
    baseNetwork: "testnet",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'tb',
    bip32: {
        public: 0x02575483,
        private: 0x02575048
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

libs.bitcoin.networks.regtest.p2wsh = {
    baseNetwork: "regtest",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bcrt',
    bip32: {
        public: 0x02575483,
        private: 0x02575048
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

// p2wsh in p2sh

libs.bitcoin.networks.bitcoin.p2wshInP2sh = {
    baseNetwork: "bitcoin",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bc',
    bip32: {
        public: 0x0295b43f,
        private: 0x0295b005
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif: 0x80
};

libs.bitcoin.networks.testnet.p2wshInP2sh = {
    baseNetwork: "testnet",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'tb',
    bip32: {
        public: 0x024289ef,
        private: 0x024285b5
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

libs.bitcoin.networks.regtest.p2wshInP2sh = {
    baseNetwork: "regtest",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'bcrt',
    bip32: {
        public: 0x024289ef,
        private: 0x024285b5
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

libs.bitcoin.networks.cranepay.p2wpkhInP2sh = {
    baseNetwork: "cranepay",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'cp',
    bip32: {
        public: 0x049d7cb2,
        private: 0x049d7878
    },
    pubKeyHash: 28,
    scriptHash: 10,
    wif: 123
};

// bech32
libs.bitcoin.networks.cranepay.p2wpkh = {
    baseNetwork: "cranepay",
    messagePrefix: '\x18Bitcoin Signed Message:\n',
    bech32: 'cp',
    bip32: {
        public: 0x04b24746,
        private: 0x04b2430c
    },
    pubKeyHash: 28,
    scriptHash: 10,
    wif: 123
};




libs.bitcoin.networks.litecoin.p2wpkh = {
    baseNetwork: "litecoin",
    messagePrefix: '\x19Litecoin Signed Message:\n',
    bech32: 'ltc',
    bip32: {
        public: 0x04b24746,
        private: 0x04b2430c
    },
    pubKeyHash: 0x30,
    scriptHash: 0x32,
    wif: 0xb0
};

libs.bitcoin.networks.litecoin.p2wpkhInP2sh = {
    baseNetwork: "litecoin",
    messagePrefix: '\x19Litecoin Signed Message:\n',
    bech32: 'ltc',
    bip32: {
        public: 0x01b26ef6,
        private: 0x01b26792
    },
    pubKeyHash: 0x30,
    scriptHash: 0x32,
    wif: 0xb0
};

libs.bitcoin.networks.fujicoin.p2wpkh = {
    baseNetwork: "fujicoin",
    messagePrefix: '\x19FujiCoin Signed Message:\n',
    bech32: 'fc',
    bip32: {
        public: 0x04b24746,
        private: 0x04b2430c
    },
    pubKeyHash: 0x24,
    scriptHash: 0x10,
    wif: 0xa4
};

libs.bitcoin.networks.fujicoin.p2wpkhInP2sh = {
    baseNetwork: "fujicoin",
    messagePrefix: '\x19FujiCoin Signed Message:\n',
    bech32: 'fc',
    bip32: {
        public: 0x049d7cb2,
        private: 0x049d7878
    },
    pubKeyHash: 0x24,
    scriptHash: 0x10,
    wif: 0xa4
};

libs.bitcoin.networks.vertcoin.p2wpkh = {
    baseNetwork: "vertcoin",
    messagePrefix: '\x18Vertcoin Signed Message:\n',
    bech32: 'vtc',
    bip32: {
        public: 0x0488b21e,
        private: 0x0488ade4
    },
    pubKeyHash: 71,
    scriptHash: 5,
    wif: 0x80
};

libs.bitcoin.networks.vertcoin.p2wpkhInP2sh = {
    baseNetwork: "vertcoin",
    messagePrefix: '\x18Vertcoin Signed Message:\n',
    bip32: {
        public: 0x0488b21e,
        private: 0x0488ade4
    },
    pubKeyHash: 71,
    scriptHash: 5,
    wif: 0x80
};

libs.bitcoin.networks.bgold.p2wpkh = {
    baseNetwork: "bgold",
    messagePrefix: '\x1DBitcoin Gold Signed Message:\n',
    bech32: 'btg',
    bip32: {
        public: 0x04b24746,
        private: 0x04b2430c
    },
    pubKeyHash: 0x26,
    scriptHash: 0x17,
    wif: 0x80,
};

libs.bitcoin.networks.bgold.p2wpkhInP2sh = {
    baseNetwork: "bgold",
    messagePrefix: '\x1DBitcoin Gold Signed Message:\n',
    bech32: 'btg',
    bip32: {
        public: 0x049d7cb2,
        private: 0x049d7878
    },
    pubKeyHash: 0x26,
    scriptHash: 0x17,
    wif: 0x80,
};

libs.bitcoin.networks.digibyte.p2wpkh = {
    baseNetwork: "digibyte",
    messagePrefix: 'x19DigiByte Signed Message:\n',
    bech32: 'dgb',
    bip32: {
        public: 0x04b24746,
        private: 0x04b2430c
    },
    pubKeyHash: 0x1e,
    scriptHash: 0x3f,
    wif: 0x80
};

libs.bitcoin.networks.digibyte.p2wpkhInP2sh = {
    baseNetwork: "digibyte",
    messagePrefix: '\x19DigiByte Signed Message:\n',
    bech32: 'dgb',
    bip32: {
        public: 0x049d7cb2,
        private: 0x049d7878
    },
    pubKeyHash: 0x1e,
    scriptHash: 0x3f,
    wif: 0x80
};

libs.bitcoin.networks.blockstamp.p2wpkh = {
    baseNetwork: "blockstamp",
    messagePrefix: '\x18BlockStamp Signed Message:\n',
    bech32: 'bc',
    bip32: {
      public: 0x0488B21E,
      private: 0x0488ADE4,
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif:  0x80,
};

libs.bitcoin.networks.blockstamp.p2wpkhInP2sh = {
    baseNetwork: "blockstamp",
    messagePrefix: '\x18BlockStamp Signed Message:\n',
    bech32: 'bc',
    bip32: {
      public: 0x0488B21E,
      private: 0x0488ADE4,
    },
    pubKeyHash: 0x00,
    scriptHash: 0x05,
    wif:  0x80,
};

libs.bitcoin.networks.nix.p2wpkh = {
    baseNetwork: "nix",
    messagePrefix: '\x18Nix Signed Message:\n',
    bech32: 'nix',
    bip32: {
        public: 0x0488b21e,
        private: 0x0488ade4,
      },
      pubKeyHash: 0x26,
      scriptHash: 0x35,
      wif: 0x80,
};

libs.bitcoin.networks.nix.p2wpkhInP2sh = {
    baseNetwork: "nix",
    messagePrefix: '\x18Nix Signed Message:\n',
    bech32: 'nix',
    bip32: {
        public: 0x0488b21e,
        private: 0x0488ade4,
      },
      pubKeyHash: 0x26,
      scriptHash: 0x35,
      wif: 0x80,
};

libs.bitcoin.networks.cpuchain.p2wpkh = {
    baseNetwork: "cpuchain",
    messagePrefix: '\x1DCPUchain Signed Message:\n',
    bech32: 'cpu',
    bip32: {
        public: 0x04b24746,
        private: 0x04b2430c
    },
    pubKeyHash: 0x1c,
    scriptHash: 0x1e,
    wif: 0x80,
};

libs.bitcoin.networks.cpuchain.p2wpkhInP2sh = {
    baseNetwork: "cpuchain",
    messagePrefix: '\x1DCPUchain Signed Message:\n',
    bech32: 'cpu',
    bip32: {
        public: 0x049d7cb2,
        private: 0x049d7878
    },
    pubKeyHash: 0x1c,
    scriptHash: 0x1e,
    wif: 0x80,
};

libs.bitcoin.networks.monkeyproject.p2wpkh = {
    baseNetwork: "monkeyproject",
	messagePrefix: 'Monkey Signed Message:\n',
	bech32: 'monkey',
	bip32: {
		public: 0x0488b21e,
		private: 0x0488dde4
	},
	pubKeyHash: 0x33,
	scriptHash: 0x1c,
	wif: 0x37
};

libs.bitcoin.networks.monkeyproject.p2wpkhInP2sh = {
	baseNetwork: "monkeyproject",
	messagePrefix: 'Monkey Signed Message:\n',
	bech32: 'monkey',
	bip32: {
		public: 0x0488b21e,
		private: 0x0488dde4
	},
	pubKeyHash: 0x33,
	scriptHash: 0x1c,
	wif: 0x37
};

libs.bitcoin.networks.atom.p2wpkh = {
    baseNetwork: "atom",
	messagePrefix: '\x18Bitcoin Atom Signed Message:\n',
	bech32: 'atom',
	bip32: {
		public: 0x0488B21E,
		private: 0x0488ADE4
	},
	pubKeyHash: 0x17,
	scriptHash: 0x0a,
	wif: 0x80
};

libs.bitcoin.networks.atom.p2wpkhInP2sh = {
	baseNetwork: "atom",
	messagePrefix: '\x18Bitcoin Atom Signed Message:\n',
	bech32: 'atom',
	bip32: {
		public: 0x0488B21E,
		private: 0x0488ADE4
	},
	pubKeyHash: 0x17,
	scriptHash: 0x0a,
	wif: 0x80
};

libs.bitcoin.networks.bitcore.p2wpkh = {
    baseNetwork: "bitcore",
	messagePrefix: '\x18BitCore Signed Message:\n',
	bech32: 'bitcore',
	bip32: {
		public: 0x0488B21E,
		private: 0x0488ADE4
	},
	pubKeyHash: 0x03,
	scriptHash: 0x7D,
	wif: 0x80
};

libs.bitcoin.networks.bitcore.p2wpkhInP2sh = {
	baseNetwork: "bitcore",
	messagePrefix: '\x18BitCore Signed Message:\n',
	bech32: 'bitcore',
	bip32: {
		public: 0x0488B21E,
		private: 0x0488ADE4
	},
	pubKeyHash: 0x03,
	scriptHash: 0x7D,
	wif: 0x80
};

libs.bitcoin.networks.monacoin.p2wpkh = {
    baseNetwork: "monacoin",
	messagePrefix: '\x18Monacoin Signed Message:\n',
	bech32: 'mona',
	bip32: {
		public: 0x0488b21e,
		private: 0x0488ade4
	},
	pubKeyHash: 0x32,
	scriptHash: 0x37,
	wif: 0xb0
};

libs.bitcoin.networks.monacoin.p2wpkhInP2sh = {
	baseNetwork: "monacoin",
	messagePrefix: '\x18Monacoin Signed Message:\n',
	bech32: 'mona',
	bip32: {
		public: 0x0488b21e,
		private: 0x0488ade4
	},
	pubKeyHash: 0x32,
	scriptHash: 0x37,
	wif: 0xb0
};

libs.bitcoin.networks.syscoin.p2wpkh = {
    baseNetwork: "syscoin",
	messagePrefix: '\x18Syscoin Signed Message:\n',
	bech32: 'sys',
	bip32: {
		public: 0x04b24746,
		private: 0x04b2430c
	},
	pubKeyHash: 0x3f,
	scriptHash: 0x05,
	wif: 0x80
};

libs.bitcoin.networks.syscoin.p2wpkhInP2sh = {
	baseNetwork: "syscoin",
	messagePrefix: '\x18Syscoin Signed Message:\n',
	bech32: 'sys',
	bip32: {
		public: 0x049d7cb2,
		private: 0x049d7878
	},
	pubKeyHash: 0x3f,
	scriptHash: 0x05,
	wif: 0x80
};

libs.bitcoin.networks.viacoin.p2wpkh = {
    baseNetwork: "viacoin",
	messagePrefix: '\x18Viacoin Signed Message:\n',
	bech32: 'viacoin',
	bip32: {
		public: 0x0488b21e,
		private: 0x0488ade4
	},
	pubKeyHash: 0x47,
	scriptHash: 0x21,
	wif: 0xc7
};

libs.bitcoin.networks.viacoin.p2wpkhInP2sh = {
	baseNetwork: "viacoin",
	messagePrefix: '\x18Viacoin Signed Message:\n',
	bech32: 'viacoin',
	bip32: {
		public: 0x0488b21e,
		private: 0x0488ade4
	},
	pubKeyHash: 0x47,
	scriptHash: 0x21,
	wif: 0xc7
};

libs.bitcoin.networks.dogecointestnet.p2wpkh = {
    baseNetwork: "dogecointestnet",
	messagePrefix: '\x19Dogecoin Signed Message:\n',
	bech32: 'dogecointestnet',
	bip32: {
		public: 0x043587cf,
		private: 0x04358394
	},
	pubKeyHash: 0x71,
	scriptHash: 0xc4,
	wif: 0xf1
};

libs.bitcoin.networks.dogecointestnet.p2wpkhInP2sh = {
	baseNetwork: "dogecointestnet",
	messagePrefix: '\x19Dogecoin Signed Message:\n',
	bech32: 'dogecointestnet',
	bip32: {
		public: 0x043587cf,
		private: 0x04358394
	},
	pubKeyHash: 0x71,
	scriptHash: 0xc4,
	wif: 0xf1
};

libs.bitcoin.networks.dogecointestnet.p2wpkh = {
    baseNetwork: "dogecointestnet",
	messagePrefix: '\x19Dogecoin Signed Message:\n',
	bech32: 'dogecointestnet',
	bip32: {
		public: 0x043587cf,
		private: 0x04358394
	},
	pubKeyHash: 0x71,
	scriptHash: 0xc4,
	wif: 0xf1
};

libs.bitcoin.networks.dogecointestnet.p2wpkhInP2sh = {
	baseNetwork: "dogecointestnet",
	messagePrefix: '\x19Dogecoin Signed Message:\n',
	bech32: 'dogecointestnet',
	bip32: {
		public: 0x043587cf,
		private: 0x04358394
	},
	pubKeyHash: 0x71,
	scriptHash: 0xc4,
	wif: 0xf1
};

libs.bitcoin.networks.litecointestnet.p2wpkh = {
    baseNetwork: "litecointestnet",
	messagePrefix: '\x18Litecoin Signed Message:\n',
	bech32: 'litecointestnet',
	bip32: {
		public: 0x043587cf,
		private: 0x04358394
	},
	pubKeyHash: 0x6f,
	scriptHash: 0xc4,
	wif: 0xef
};

libs.bitcoin.networks.litecointestnet.p2wpkhInP2sh = {
	baseNetwork: "litecointestnet",
	messagePrefix: '\x18Litecoin Signed Message:\n',
	bech32: 'litecointestnet',
	bip32: {
		public: 0x043587cf,
		private: 0x04358394
	},
	pubKeyHash: 0x6f,
	scriptHash: 0xc4,
	wif: 0xef
};

libs.bitcoin.networks.groestlcoin.p2wpkh = {
    baseNetwork: "groestlcoin",
    messagePrefix: '\x19GroestlCoin Signed Message:\n',
    bech32: 'grs',
    bip32: {
        public: 0x04b24746,
        private: 0x04b2430c
    },
    pubKeyHash: 0x24,
    scriptHash: 0x05,
    wif: 0x80,
};

libs.bitcoin.networks.groestlcointestnet.p2wpkh = {
    baseNetwork: "groestlcointestnet",
    messagePrefix: '\x19GroestlCoin Signed Message:\n',
    bech32: 'tgrs',
    bip32: {
        public: 0x045f1cf6,
        private: 0x045f18bc
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

libs.bitcoin.networks.groestlcoin.p2wpkhInP2sh = {
    baseNetwork: "groestlcoin",
    messagePrefix: '\x19GroestlCoin Signed Message:\n',
    bech32: 'grs',
    bip32: {
        public: 0x049d7cb2,
        private: 0x049d7878
    },
    pubKeyHash: 0x24,
    scriptHash: 0x05,
    wif: 0x80,
};

libs.bitcoin.networks.groestlcointestnet.p2wpkhInP2sh = {
    baseNetwork: "groestlcointestnet",
    messagePrefix: '\x19GroestlCoin Signed Message:\n',
    bech32: 'tgrs',
    bip32: {
        public: 0x044a5262,
        private: 0x044a4e28
    },
    pubKeyHash: 0x6f,
    scriptHash: 0xc4,
    wif: 0xef
};

libs.bitcoin.networks.deeponion.p2wpkh = {
    baseNetwork: "deeponion",
	messagePrefix: '\x18DeepOnion Signed Message:\n',
	bech32: 'dpn',
	bip32: {
		public: 0x0488b21e,
		private: 0x0488ade4
	},
	pubKeyHash: 0x1f,
	scriptHash: 0x4e,
	wif: 0x9f
};

libs.bitcoin.networks.deeponion.p2wpkhInP2sh = {
	baseNetwork: "deeponion",
	messagePrefix: '\x18DeepOnion Signed Message:\n',
	bech32: 'dpn',
	bip32: {
		public: 0x0488b21e,
		private: 0x0488ade4
	},
	pubKeyHash: 0x1f,
	scriptHash: 0x4e,
	wif: 0x9f
};

libs.bitcoin.networks.sugarchain.p2wpkh = {
	baseNetwork: "sugarchain",
	messagePrefix: '\x1DSugarchain Signed Message:\n',
	bech32: 'sugar',
	bip32: {
		public: 0x04b24746,
		private: 0x04b2430c
	},
	pubKeyHash: 0x3f,
	scriptHash: 0x7d,
	wif: 0x80
};

libs.bitcoin.networks.sugarchain.p2wpkhInP2sh = {
	baseNetwork: "sugarchain",
	messagePrefix: '\x1DSugarchain Signed Message:\n',
	bech32: 'sugar',
	bip32: {
		public: 0x049d7cb2,
		private: 0x049d7878
	},
	pubKeyHash: 0x3f,
	scriptHash: 0x7d,
	wif: 0x80
};

libs.bitcoin.networks.sugarchaintestnet.p2wpkh = {
	baseNetwork: "sugarchaintestnet",
	messagePrefix: '\x18Sugarchain Signed Message:\n',
	bech32: 'tugar',
	bip32: {
		public: 0x045f1cf6,
		private: 0x045f18bc
	},
	pubKeyHash: 0x42,
	scriptHash: 0x80,
	wif: 0xef
};

libs.bitcoin.networks.sugarchaintestnet.p2wpkhInP2sh = {
	baseNetwork: "sugarchaintestnet",
	messagePrefix: '\x18Sugarchain Signed Message:\n',
	bech32: 'tugar',
	bip32: {
		public: 0x044a5262,
		private: 0x044a4e28
	},
	pubKeyHash: 0x42,
	scriptHash: 0x80,
	wif: 0xef
};

})();
</script>



<script>
/*
function convertRippleAdrr(address) {
    return libs.basex('rpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65jkm8oFqi1tuvAxyz').encode(
       libs.basex('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz').decode(address)
    )
}

function convertRipplePriv(priv)   {
    return libs.basex('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz').decode(priv).toString("hex").slice(2,66)
}

function convertJingtumAdrr(address) {
    return libs.basex('jpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2bcdeCg65rkm8oFqi1tuvAxyz').encode(
        libs.basex('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz').decode(address)
    )
}

function convertJingtumPriv(priv)   {
    return libs.basex('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz').decode(priv).toString("hex").slice(2,66)
}

function convertCasinoCoinAdrr(address) {
    return libs.basex('cpshnaf39wBUDNEGHJKLM4PQRST7VWXYZ2brdeCg65jkm8oFqi1tuvAxyz').encode(
        libs.basex('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz').decode(address)
    )
}

function convertCasinoCoinPriv(priv)   {
    return libs.basex('123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz').decode(priv).toString("hex").slice(2,66)
}

function CosmosBufferToPublic(pubBuf, hrp = "cosmos") {
  const Buffer = libs.buffer.Buffer;
  const AminoSecp256k1PubkeyPrefix = Buffer.from("EB5AE987", "hex");
  const AminoSecp256k1PubkeyLength = Buffer.from("21", "hex");
  pubBuf = Buffer.concat([AminoSecp256k1PubkeyPrefix, AminoSecp256k1PubkeyLength, pubBuf]);
  return libs.bech32.encode(`${hrp}pub`, libs.bech32.toWords(pubBuf));
}

function CosmosBufferToAddress(pubBuf, hrp = "cosmos") {
  const sha256_ed = libs.createHash("sha256").update(pubBuf).digest();
  const ripemd160_ed = libs.createHash("rmd160").update(sha256_ed).digest();
  return libs.bech32.encode(hrp, libs.bech32.toWords(ripemd160_ed));
}

function EOSbufferToPublic(pubBuf) {
  const Buffer = libs.buffer.Buffer;
  const EOS_PUBLIC_PREFIX = "EOS";
  let checksum = libs.createHash("rmd160").update(pubBuf).digest("hex").slice(0, 8);
  pubBuf = Buffer.concat([pubBuf, Buffer.from(checksum, "hex")]);
  return EOS_PUBLIC_PREFIX.concat(libs.bs58.encode(pubBuf));
}

function EOSbufferToPrivate(privBuf) {
  const Buffer = libs.buffer.Buffer;
  const EOS_PRIVATE_PREFIX = "80";
  privBuf = Buffer.concat([Buffer.from(EOS_PRIVATE_PREFIX, "hex"), privBuf]);
  let tmp = libs.createHash("sha256").update(privBuf).digest();
  let checksum = libs.createHash("sha256").update(tmp).digest("hex").slice(0, 8);
  privBuf = Buffer.concat([privBuf, Buffer.from(checksum, "hex")]);
  return libs.bs58.encode(privBuf);
}

function FIObufferToPublic(pubBuf) {
  const Buffer = libs.buffer.Buffer;
  const FIO_PUBLIC_PREFIX = "FIO";

  let checksum = libs.createHash("rmd160").update(pubBuf).digest("hex").slice(0, 8);
  pubBuf = Buffer.concat([pubBuf, Buffer.from(checksum, "hex")]);
  return FIO_PUBLIC_PREFIX.concat(libs.bs58.encode(pubBuf));
}

function FIObufferToPrivate(privBuf) {
  const Buffer = libs.buffer.Buffer;
  const FIO_PRIVATE_PREFIX = "80";

  privBuf = Buffer.concat([Buffer.from(FIO_PRIVATE_PREFIX, "hex"), privBuf]);
  let tmp = libs.createHash("sha256").update(privBuf).digest();
  let checksum = libs.createHash("sha256").update(tmp).digest("hex").slice(0, 8);
  privBuf = Buffer.concat([privBuf, Buffer.from(checksum, "hex")]);
  return libs.bs58.encode(privBuf);
}

function XWCbufferToAddress(pubBuf){
  const Buffer = libs.buffer.Buffer;
  const XWC_ADDRESS_PREFIX = "XWC";
  const XWC_NORMAL_ADDRESS_VERSION = "35"
  let addrData = libs.createHash("rmd160").update( libs.createHash("sha512").update(pubBuf).digest()).digest();
  let addrBuf = Buffer.concat([Buffer.from(XWC_NORMAL_ADDRESS_VERSION, "hex") ,addrData])
  let checksum = libs.createHash("rmd160").update(addrBuf).digest("hex").slice(0, 8);
  addrBuf = Buffer.concat([addrBuf, Buffer.from(checksum, "hex")]);
  return XWC_ADDRESS_PREFIX.concat(libs.bs58.encode(addrBuf));
}

function XWCbufferToPublic(pubBuf) {
  const Buffer = libs.buffer.Buffer;
  const XWC_PUBLIC_PREFIX = "XWC";
  let checksum = libs.createHash("rmd160").update(pubBuf).digest("hex").slice(0, 8);
  pubBuf = Buffer.concat([pubBuf, Buffer.from(checksum, "hex")]);
  return XWC_PUBLIC_PREFIX.concat(libs.bs58.encode(pubBuf));
}

function XWCbufferToPrivate(privBuf) {
  const Buffer = libs.buffer.Buffer;
  const XWC_PRIVATE_PREFIX = "80";
  privBuf = Buffer.concat([Buffer.from(XWC_PRIVATE_PREFIX, "hex"), privBuf]);
  let tmp = libs.createHash("sha256").update(privBuf).digest();
  let checksum = libs.createHash("sha256").update(tmp).digest("hex").slice(0, 8);
  privBuf = Buffer.concat([privBuf, Buffer.from(checksum, "hex")]);
  return libs.bs58.encode(privBuf);
}
*/
</script>


<script src="sjcl.js"></script>
<script src="wordlists.js"></script>
<script src="mnemonic.js"></script>
<script src="entropy.js"></script>


<script>
(function() {
    // mnemonics is populated as required by getLanguage
    var mnemonics = { "english": new Mnemonic("english") };
    var mnemonic = mnemonics["english"];
    var seed = null;
    var bip32RootKey = null;
    var bip32ExtendedKey = null;
    var network = libs.bitcoin.networks.bitcoin;
    var addressRowTemplate = $("#address-row-template");

    var showIndex = true;
    var showAddress = true;
    var showPubKey = true;
    var showPrivKey = true;
    var showQr = false;
    var litecoinUseLtub = true;

    var entropyTypeAutoDetect = true;
    var entropyChangeTimeoutEvent = null;
    var phraseChangeTimeoutEvent = null;
    var seedChangedTimeoutEvent = null;
    var rootKeyChangedTimeoutEvent = null;

    var generationProcesses = [];

    var DOM = {};
    DOM.privacyScreenToggle = $(".privacy-screen-toggle");
    DOM.network = $(".network");
    DOM.bip32Client = $("#bip32-client");
    DOM.phraseNetwork = $("#network-phrase");
    DOM.useEntropy = $(".use-entropy");
    DOM.entropyContainer = $(".entropy-container");
    DOM.entropy = $(".entropy");
    DOM.entropyFiltered = DOM.entropyContainer.find(".filtered");
    DOM.entropyType = DOM.entropyContainer.find(".type");
    DOM.entropyTypeInputs = DOM.entropyContainer.find("input[name='entropy-type']");
    DOM.entropyCrackTime = DOM.entropyContainer.find(".crack-time");
    DOM.entropyEventCount = DOM.entropyContainer.find(".event-count");
    DOM.entropyBits = DOM.entropyContainer.find(".bits");
    DOM.entropyBitsPerEvent = DOM.entropyContainer.find(".bits-per-event");
    DOM.entropyWordCount = DOM.entropyContainer.find(".word-count");
    DOM.entropyBinary = DOM.entropyContainer.find(".binary");
    DOM.entropyWordIndexes = DOM.entropyContainer.find(".word-indexes");
    DOM.entropyChecksum = DOM.entropyContainer.find(".checksum");
    DOM.entropyMnemonicLength = DOM.entropyContainer.find(".mnemonic-length");
    DOM.pbkdf2Rounds = DOM.entropyContainer.find(".pbkdf2-rounds");
    DOM.pbkdf2CustomInput = DOM.entropyContainer.find("#pbkdf2-custom-input");
    DOM.pbkdf2InfosDanger = $(".PBKDF2-infos-danger");
    DOM.entropyWeakEntropyOverrideWarning = DOM.entropyContainer.find(".weak-entropy-override-warning");
    DOM.entropyFilterWarning = DOM.entropyContainer.find(".filter-warning");
    DOM.phrase = $(".phrase");
    DOM.autoCompute = $(".autoCompute");
    DOM.splitMnemonic = $(".splitMnemonic");
    DOM.showSplitMnemonic = $(".showSplitMnemonic");
    DOM.phraseSplit = $(".phraseSplit");
    DOM.phraseSplitWarn = $(".phraseSplitWarn");
    DOM.passphrase = $(".passphrase");
    DOM.generateContainer = $(".generate-container");
    DOM.generate = $(".generate");
    DOM.seed = $(".seed");
    DOM.rootKey = $(".root-key");
    DOM.litecoinLtubContainer = $(".litecoin-ltub-container");
    DOM.litecoinUseLtub = $(".litecoin-use-ltub");
    DOM.extendedPrivKey = $(".extended-priv-key");
    DOM.extendedPubKey = $(".extended-pub-key");
    DOM.bip32tab = $("#bip32-tab");
    DOM.bip44tab = $("#bip44-tab");
    DOM.bip49tab = $("#bip49-tab");
    DOM.bip84tab = $("#bip84-tab");
    DOM.bip141tab = $("#bip141-tab");
    DOM.bip32panel = $("#bip32");
    DOM.bip44panel = $("#bip44");
    DOM.bip49panel = $("#bip49");
    DOM.bip32path = $("#bip32-path");
    DOM.bip44path = $("#bip44-path");
    DOM.bip44purpose = $("#bip44 .purpose");
    DOM.bip44coin = $("#bip44 .coin");
    DOM.bip44account = $("#bip44 .account");
    DOM.bip44accountXprv = $("#bip44 .account-xprv");
    DOM.bip44accountXpub = $("#bip44 .account-xpub");
    DOM.bip44change = $("#bip44 .change");
    DOM.bip49unavailable = $("#bip49 .unavailable");
    DOM.bip49available = $("#bip49 .available");
    DOM.bip49path = $("#bip49-path");
    DOM.bip49purpose = $("#bip49 .purpose");
    DOM.bip49coin = $("#bip49 .coin");
    DOM.bip49account = $("#bip49 .account");
    DOM.bip49accountXprv = $("#bip49 .account-xprv");
    DOM.bip49accountXpub = $("#bip49 .account-xpub");
    DOM.bip49change = $("#bip49 .change");
    DOM.bip84unavailable = $("#bip84 .unavailable");
    DOM.bip84available = $("#bip84 .available");
    DOM.bip84path = $("#bip84-path");
    DOM.bip84purpose = $("#bip84 .purpose");
    DOM.bip84coin = $("#bip84 .coin");
    DOM.bip84account = $("#bip84 .account");
    DOM.bip84accountXprv = $("#bip84 .account-xprv");
    DOM.bip84accountXpub = $("#bip84 .account-xpub");
    DOM.bip84change = $("#bip84 .change");
    DOM.bip85 = $('.bip85');
    DOM.showBip85 = $('.showBip85');
    DOM.bip85Field = $('.bip85Field');
    DOM.bip85application = $('#bip85-application');
    DOM.bip85mnemonicLanguage = $('#bip85-mnemonic-language');
    DOM.bip85mnemonicLanguageInput = $('.bip85-mnemonic-language-input');
    DOM.bip85mnemonicLength = $('#bip85-mnemonic-length');
    DOM.bip85mnemonicLengthInput = $('.bip85-mnemonic-length-input');
    DOM.bip85index = $('#bip85-index');
    DOM.bip85indexInput = $('.bip85-index-input');
    DOM.bip85bytes = $('#bip85-bytes');
    DOM.bip85bytesInput = $('.bip85-bytes-input');
    DOM.bip141unavailable = $("#bip141 .unavailable");
    DOM.bip141available = $("#bip141 .available");
    DOM.bip141path = $("#bip141-path");
    DOM.bip141semantics = $(".bip141-semantics");
    DOM.generatedStrength = $(".generate-container .strength");
    DOM.generatedStrengthWarning = $(".generate-container .warning");
    DOM.hardenedAddresses = $(".hardened-addresses");
    DOM.bitcoinCashAddressTypeContainer = $(".bch-addr-type-container");
    DOM.bitcoinCashAddressType = $("[name=bch-addr-type]")
    DOM.useBip38 = $(".use-bip38");
    DOM.bip38Password = $(".bip38-password");
    DOM.addresses = $(".addresses");
    DOM.csvTab = $("#csv-tab a");
    DOM.csv = $(".csv");
    DOM.rowsToAdd = $(".rows-to-add");
    DOM.more = $(".more");
    DOM.moreRowsStartIndex = $(".more-rows-start-index");
    DOM.feedback = $(".feedback");
    DOM.tab = $(".derivation-type a");
    DOM.indexToggle = $(".index-toggle");
    DOM.addressToggle = $(".address-toggle");
    DOM.publicKeyToggle = $(".public-key-toggle");
    DOM.privateKeyToggle = $(".private-key-toggle");
    DOM.languages = $(".languages a");
    DOM.qrContainer = $(".qr-container");
    DOM.qrHider = DOM.qrContainer.find(".qr-hider");
    DOM.qrImage = DOM.qrContainer.find(".qr-image");
    DOM.qrHint = DOM.qrContainer.find(".qr-hint");
    DOM.showQrEls = $("[data-show-qr]");

    function init() {
        // Events
        DOM.privacyScreenToggle.on("change", privacyScreenToggled);
        DOM.generatedStrength.on("change", generatedStrengthChanged);
        DOM.network.on("change", networkChanged);
        DOM.bip32Client.on("change", bip32ClientChanged);
        DOM.useEntropy.on("change", setEntropyVisibility);
        DOM.autoCompute.on("change", delayedPhraseChanged);
        DOM.entropy.on("input", delayedEntropyChanged);
        DOM.entropyMnemonicLength.on("change", entropyChanged);
        DOM.pbkdf2Rounds.on("change", pbkdf2RoundsChanged);
        DOM.pbkdf2CustomInput.on("change", pbkdf2RoundsChanged);
        DOM.entropyTypeInputs.on("change", entropyTypeChanged);
        DOM.phrase.on("input", delayedPhraseChanged);
        DOM.showSplitMnemonic.on("change", toggleSplitMnemonic);
        DOM.passphrase.on("input", delayedPhraseChanged);
        DOM.generate.on("click", generateClicked);
        DOM.more.on("click", showMore);
        DOM.seed.on("input", delayedSeedChanged);
        DOM.rootKey.on("input", delayedRootKeyChanged);
        DOM.showBip85.on('change', toggleBip85);
        DOM.litecoinUseLtub.on("change", litecoinUseLtubChanged);
        DOM.bip32path.on("input", calcForDerivationPath);
        DOM.bip44account.on("input", calcForDerivationPath);
        DOM.bip44change.on("input", calcForDerivationPath);
        DOM.bip49account.on("input", calcForDerivationPath);
        DOM.bip49change.on("input", calcForDerivationPath);
        DOM.bip84account.on("input", calcForDerivationPath);
        DOM.bip84change.on("input", calcForDerivationPath);
        DOM.bip85application.on('input', calcBip85);
        DOM.bip85mnemonicLanguage.on('change', calcBip85);
        DOM.bip85mnemonicLength.on('change', calcBip85);
        DOM.bip85index.on('input', calcBip85);
        DOM.bip85bytes.on('input', calcBip85);
        DOM.bip141path.on("input", calcForDerivationPath);
        DOM.bip141semantics.on("change", tabChanged);
        DOM.tab.on("shown.bs.tab", tabChanged);
        DOM.hardenedAddresses.on("change", calcForDerivationPath);
        DOM.useBip38.on("change", calcForDerivationPath);
        DOM.bip38Password.on("change", calcForDerivationPath);
        DOM.indexToggle.on("click", toggleIndexes);
        DOM.addressToggle.on("click", toggleAddresses);
        DOM.publicKeyToggle.on("click", togglePublicKeys);
        DOM.privateKeyToggle.on("click", togglePrivateKeys);
        DOM.csvTab.on("click", updateCsv);
        DOM.languages.on("click", languageChanged);
        DOM.bitcoinCashAddressType.on("change", bitcoinCashAddressTypeChange);
        setQrEvents(DOM.showQrEls);
        disableForms();
        hidePending();
        hideValidationError();
        populateNetworkSelect();
        populateClientSelect();
    }

    // Event handlers

    function generatedStrengthChanged() {
        var strength = parseInt(DOM.generatedStrength.val());
        if (strength < 12) {
            DOM.generatedStrengthWarning.removeClass("hidden");
        }
        else {
            DOM.generatedStrengthWarning.addClass("hidden");
        }
    }

    function networkChanged(e) {
        clearDerivedKeys();
        clearAddressesList();
        DOM.litecoinLtubContainer.addClass("hidden");
        DOM.bitcoinCashAddressTypeContainer.addClass("hidden");
        var networkIndex = e.target.value;
        var network = networks[networkIndex];
        network.onSelect();
        adjustNetworkForSegwit();
        if (seed != null) {
            seedChanged()
        }
        else {
            rootKeyChanged();
        }
    }

    function bip32ClientChanged(e) {
        var clientIndex = DOM.bip32Client.val();
        if (clientIndex == "custom") {
            DOM.bip32path.prop("readonly", false);
        }
        else {
            DOM.bip32path.prop("readonly", true);
            clients[clientIndex].onSelect();
            rootKeyChanged();
        }
    }

    function isUsingAutoCompute() {
        return DOM.autoCompute.prop("checked");
    }

    function setEntropyVisibility() {
        if (isUsingOwnEntropy()) {
            DOM.entropyContainer.removeClass("hidden");
            DOM.generateContainer.addClass("hidden");
            DOM.phrase.prop("readonly", true);
            DOM.entropy.focus();
            entropyChanged();
        }
        else {
            DOM.entropyContainer.addClass("hidden");
            DOM.generateContainer.removeClass("hidden");
            DOM.phrase.prop("readonly", false);
            hidePending();
        }
    }

    function delayedPhraseChanged() {

        if(isUsingAutoCompute()) {
        hideValidationError();
        seed = null;
        bip32RootKey = null;
        bip32ExtendedKey = null;
        clearAddressesList();
        showPending();
        if (phraseChangeTimeoutEvent != null) {
            clearTimeout(phraseChangeTimeoutEvent);
        }
        phraseChangeTimeoutEvent = setTimeout(function() {
            phraseChanged();
            var entropy = mnemonic.toRawEntropyHex(DOM.phrase.val());
            if (entropy !== null) {
                DOM.entropyMnemonicLength.val("raw");
                DOM.entropy.val(entropy);
                DOM.entropyTypeInputs.filter("[value='hexadecimal']").prop("checked", true);
                entropyTypeAutoDetect = false;
            }
        }, 400);
    } else {
        clearDisplay();
        clearEntropyFeedback();
        showValidationError("Auto compute is disabled");
    }
    }

    function phraseChanged() {
        showPending();
        setMnemonicLanguage();
        // Get the mnemonic phrase
        var phrase = DOM.phrase.val();
        var errorText = findPhraseErrors(phrase);
        if (errorText) {
            showValidationError(errorText);
            return;
        }
        // Calculate and display
        var passphrase = DOM.passphrase.val();
        calcBip32RootKeyFromSeed(phrase, passphrase);
        calcForDerivationPath();
        calcBip85();
        // Show the word indexes
        showWordIndexes();
        writeSplitPhrase(phrase);
    }

    function tabChanged() {
        showPending();
        adjustNetworkForSegwit();
        var phrase = DOM.phrase.val();
        var seed = DOM.seed.val();
        if (phrase != "") {
            // Calculate and display for mnemonic
            var errorText = findPhraseErrors(phrase);
            if (errorText) {
                showValidationError(errorText);
                return;
            }
            // Calculate and display
            var passphrase = DOM.passphrase.val();
            calcBip32RootKeyFromSeed(phrase, passphrase);
        }
        else if (seed != "") {
          bip32RootKey = libs.bitcoin.HDNode.fromSeedHex(seed, network);
          var rootKeyBase58 = bip32RootKey.toBase58();
          DOM.rootKey.val(rootKeyBase58);
        }
        else {
            // Calculate and display for root key
            var rootKeyBase58 = DOM.rootKey.val();
            var errorText = validateRootKey(rootKeyBase58);
            if (errorText) {
                showValidationError(errorText);
                return;
            }
            // Calculate and display
            calcBip32RootKeyFromBase58(rootKeyBase58);
        }
        calcForDerivationPath();
    }

    function delayedEntropyChanged() {
        hideValidationError();
        showPending();
        if (entropyChangeTimeoutEvent != null) {
            clearTimeout(entropyChangeTimeoutEvent);
        }
        entropyChangeTimeoutEvent = setTimeout(entropyChanged, 400);
    }

    function pbkdf2RoundsChanged() {
        if (DOM.pbkdf2Rounds.val() == "custom") {
            PBKDF2_ROUNDS = DOM.pbkdf2CustomInput.val();
            DOM.pbkdf2CustomInput.removeClass("hidden");
        } else {
            PBKDF2_ROUNDS = DOM.pbkdf2Rounds.val();
            DOM.pbkdf2CustomInput.addClass("hidden");
        }
        ispbkdf2Rounds2048();
        phraseChanged();
    }
    function ispbkdf2Rounds2048() {
        if (PBKDF2_ROUNDS == 2048) {
            DOM.pbkdf2InfosDanger.addClass("hidden");
        } else {
            DOM.pbkdf2InfosDanger.removeClass("hidden");
        }
    }
    function entropyChanged() {
        // If blank entropy, clear mnemonic, addresses, errors
        if (DOM.entropy.val().trim().length == 0) {
            clearDisplay();
            clearEntropyFeedback();
            DOM.phrase.val("");
            DOM.phraseSplit.val("");
            showValidationError("Blank entropy");
            return;
        }
        // Get the current phrase to detect changes
        var phrase = DOM.phrase.val();
        // Set the phrase from the entropy
        setMnemonicFromEntropy();
        // Recalc addresses if the phrase has changed
        var newPhrase = DOM.phrase.val();
        if (newPhrase != phrase) {
            if (newPhrase.length == 0) {
                clearDisplay();
            }
            else {
                phraseChanged();
            }
        }
        else {
            hidePending();
        }
    }

    function entropyTypeChanged() {
        entropyTypeAutoDetect = false;
        entropyChanged();
    }

    function delayedSeedChanged() {
        // Warn if there is an existing mnemonic or passphrase.
        if (DOM.phrase.val().length > 0 || DOM.passphrase.val().length > 0) {
            if (!confirm("This will clear existing mnemonic and passphrase")) {
                DOM.seed.val(seed);
                return
            }
        }
        hideValidationError();
        showPending();
        // Clear existing mnemonic and passphrase
        DOM.phrase.val("");
        DOM.phraseSplit.val("");
        DOM.passphrase.val("");
        DOM.rootKey.val("");
        clearAddressesList();
        clearDerivedKeys();
        seed = null;
        if (seedChangedTimeoutEvent != null) {
            clearTimeout(seedChangedTimeoutEvent);
        }
        seedChangedTimeoutEvent = setTimeout(seedChanged, 400);
    }

    function delayedRootKeyChanged() {
        // Warn if there is an existing mnemonic or passphrase.
        if (DOM.phrase.val().length > 0 || DOM.passphrase.val().length > 0) {
            if (!confirm("This will clear existing mnemonic and passphrase")) {
                DOM.rootKey.val(bip32RootKey);
                return
            }
        }
        hideValidationError();
        showPending();
        // Clear existing mnemonic and passphrase
        DOM.phrase.val("");
        DOM.phraseSplit.val("");
        DOM.passphrase.val("");
        seed = null;
        if (rootKeyChangedTimeoutEvent != null) {
            clearTimeout(rootKeyChangedTimeoutEvent);
        }
        rootKeyChangedTimeoutEvent = setTimeout(rootKeyChanged, 400);
    }

    function seedChanged() {
        showPending();
        hideValidationError();
        seed = DOM.seed.val();
        bip32RootKey = libs.bitcoin.HDNode.fromSeedHex(seed, network);
        var rootKeyBase58 = bip32RootKey.toBase58();
        DOM.rootKey.val(rootKeyBase58);
        var errorText = validateRootKey(rootKeyBase58);
        if (errorText) {
            showValidationError(errorText);
            return;
        }
        // Calculate and display
        calcForDerivationPath();
        calcBip85();
    }

    function rootKeyChanged() {
        showPending();
        hideValidationError();
        var rootKeyBase58 = DOM.rootKey.val();
        var errorText = validateRootKey(rootKeyBase58);
        if (errorText) {
            showValidationError(errorText);
            return;
        }
        // Calculate and display
        calcBip32RootKeyFromBase58(rootKeyBase58);
        calcForDerivationPath();
        calcBip85();
    }

    function litecoinUseLtubChanged() {
        litecoinUseLtub = DOM.litecoinUseLtub.prop("checked");
        if (litecoinUseLtub) {
            network = libs.bitcoin.networks.litecoin;
        }
        else {
            network = libs.bitcoin.networks.litecoinXprv;
        }
        // Can't use rootKeyChanged because validation will fail as we changed
        // the network but the version bytes stayed as previously.
        seedChanged();
    }

    function toggleSplitMnemonic() {
        if (DOM.showSplitMnemonic.prop("checked")) {
            DOM.splitMnemonic.removeClass("hidden");
        }
        else {
            DOM.splitMnemonic.addClass("hidden");
        }
    }

    function toggleBip85() {
      if (DOM.showBip85.prop('checked')) {
        DOM.bip85.removeClass('hidden');
        calcBip85();
      } else {
        DOM.bip85.addClass('hidden');
      }
    }

    function toggleBip85Fields() {
      if (DOM.showBip85.prop('checked')) {
        DOM.bip85mnemonicLanguageInput.addClass('hidden');
        DOM.bip85mnemonicLengthInput.addClass('hidden');
        DOM.bip85bytesInput.addClass('hidden');

        var app = DOM.bip85application.val();
        if (app === 'bip39') {
          DOM.bip85mnemonicLanguageInput.removeClass('hidden');
          DOM.bip85mnemonicLengthInput.removeClass('hidden');
        } else if (app === 'hex') {
          DOM.bip85bytesInput.removeClass('hidden');
        }
      }
    }

    function calcBip85() {
      if (!DOM.showBip85.prop('checked')) {
        return
      }

      toggleBip85Fields();

      var app = DOM.bip85application.val();

      var rootKeyBase58 = DOM.rootKey.val();
      if (!rootKeyBase58) {
        return;
      }
      try {
        // try parsing using base network params
        // The bip85 lib only understands xpubs, so compute it
        var rootKey = libs.bitcoin.HDNode.fromBase58(rootKeyBase58, network);
        rootKey.keyPair.network = libs.bitcoin.networks['bitcoin']
        var master = libs.bip85.BIP85.fromBase58(rootKey.toBase58());

        var result;

        const index = parseInt(DOM.bip85index.val(), 10);

        if (app === 'bip39') {
          const language = parseInt(DOM.bip85mnemonicLanguage.val(), 10);
          const length = parseInt(DOM.bip85mnemonicLength.val(), 10);

          result = master.deriveBIP39(language, length, index).toMnemonic();
        } else if (app === 'wif') {
          result = master.deriveWIF(index).toWIF();
        } else if (app === 'xprv') {
          result = master.deriveXPRV(index).toXPRV();
        } else if (app === 'hex') {
          const bytes = parseInt(DOM.bip85bytes.val(), 10);

          result = master.deriveHex(bytes, index).toEntropy();
        }

        hideValidationError();
        DOM.bip85Field.val(result);
      } catch (e) {
        showValidationError('BIP85: ' + e.message);
        DOM.bip85Field.val('');
      }
    }

    function calcForDerivationPath() {
        clearDerivedKeys();
        clearAddressesList();
        showPending();
        // Don't show segwit if it's selected but network doesn't support it
        if (segwitSelected() && !networkHasSegwit()) {
            showSegwitUnavailable();
            hidePending();
            return;
        }
        showSegwitAvailable();
        // Get the derivation path
        var derivationPath = getDerivationPath();
        var errorText = findDerivationPathErrors(derivationPath);
        if (errorText) {
            showValidationError(errorText);
            return;
        }
        bip32ExtendedKey = calcBip32ExtendedKey(derivationPath);
        if (bip44TabSelected()) {
            displayBip44Info();
        }
        else if (bip49TabSelected()) {
            displayBip49Info();
        }
        else if (bip84TabSelected()) {
            displayBip84Info();
        }
        displayBip32Info();
    }

    function generateClicked() {
        if (isUsingOwnEntropy()) {
            return;
        }
        // Pressing enter on BIP85 index field triggers generate click event.
        // See https://github.com/iancoleman/bip39/issues/634
        // To cancel the incorrect generation process, stop here if generate is
        // not focused.
        var buttonIsFocused = DOM.generate[0].contains(document.activeElement);
        if (!buttonIsFocused) {
            return;
        }
        clearDisplay();
        showPending();
        setTimeout(function() {
            setMnemonicLanguage();
            var phrase = generateRandomPhrase();
            if (!phrase) {
                return;
            }
            phraseChanged();
        }, 50);
    }

    function languageChanged() {
        setTimeout(function() {
            setMnemonicLanguage();
            if (DOM.phrase.val().length > 0) {
                var newPhrase = convertPhraseToNewLanguage();
                DOM.phrase.val(newPhrase);
                phraseChanged();
            }
            else {
                DOM.generate.trigger("click");
            }
        }, 50);
    }

    function bitcoinCashAddressTypeChange() {
        rootKeyChanged();
    }

    function toggleIndexes() {
        showIndex = !showIndex;
        $("td.index span").toggleClass("invisible");
    }

    function toggleAddresses() {
        showAddress = !showAddress;
        $("td.address span").toggleClass("invisible");
    }

    function togglePublicKeys() {
        showPubKey = !showPubKey;
        $("td.pubkey span").toggleClass("invisible");
    }

    function togglePrivateKeys() {
        showPrivKey = !showPrivKey;
        $("td.privkey span").toggleClass("invisible");
    }

    function privacyScreenToggled() {
        // private-data contains elements added to DOM at runtime
        // so catch all by adding visual privacy class to the root of the DOM
        if (DOM.privacyScreenToggle.prop("checked")) {
            $("body").addClass("visual-privacy");
        }
        else {
            $("body").removeClass("visual-privacy");
        }
    }

    // Private methods

    function generateRandomPhrase() {
        if (!hasStrongRandom()) {
            var errorText = "This browser does not support strong randomness";
            showValidationError(errorText);
            return;
        }
        // get the amount of entropy to use
        var numWords = parseInt(DOM.generatedStrength.val());
        var strength = numWords / 3 * 32;
        var buffer = new Uint8Array(strength / 8);
        // create secure entropy
        var data = crypto.getRandomValues(buffer);
        // show the words
        var words = mnemonic.toMnemonic(data);
        DOM.phrase.val(words);
        // show the entropy
        var entropyHex = uint8ArrayToHex(data);
        DOM.entropy.val(entropyHex);
        // ensure entropy fields are consistent with what is being displayed
        DOM.entropyMnemonicLength.val("raw");
        console.log(words);//DEBUG
        return words;
    }

    function calcBip32RootKeyFromSeed(phrase, passphrase) {
        seed = mnemonic.toSeed(phrase, passphrase);
        bip32RootKey = libs.bitcoin.HDNode.fromSeedHex(seed, network);
        if(isGRS())
            bip32RootKey = libs.groestlcoinjs.HDNode.fromSeedHex(seed, network);

    }

    function calcBip32RootKeyFromBase58(rootKeyBase58) {
        if(isGRS()) {
            calcBip32RootKeyFromBase58GRS(rootKeyBase58);
            return;
        }
        // try parsing with various segwit network params since this extended
        // key may be from any one of them.
        if (networkHasSegwit()) {
            var n = network;
            if ("baseNetwork" in n) {
                n = libs.bitcoin.networks[n.baseNetwork];
            }
            // try parsing using base network params
            try {
                bip32RootKey = libs.bitcoin.HDNode.fromBase58(rootKeyBase58, n);
                return;
            }
            catch (e) {}
            // try parsing using p2wpkh params
            if ("p2wpkh" in n) {
                try {
                    bip32RootKey = libs.bitcoin.HDNode.fromBase58(rootKeyBase58, n.p2wpkh);
                    return;
                }
                catch (e) {}
            }
            // try parsing using p2wpkh-in-p2sh network params
            if ("p2wpkhInP2sh" in n) {
                try {
                    bip32RootKey = libs.bitcoin.HDNode.fromBase58(rootKeyBase58, n.p2wpkhInP2sh);
                    return;
                }
                catch (e) {}
            }
            // try parsing using p2wsh network params
            if ("p2wsh" in n) {
                try {
                    bip32RootKey = libs.bitcoin.HDNode.fromBase58(rootKeyBase58, n.p2wsh);
                    return;
                }
                catch (e) {}
            }
            // try parsing using p2wsh-in-p2sh network params
            if ("p2wshInP2sh" in n) {
                try {
                    bip32RootKey = libs.bitcoin.HDNode.fromBase58(rootKeyBase58, n.p2wshInP2sh);
                    return;
                }
                catch (e) {}
            }
        }
        // try the network params as currently specified
        bip32RootKey = libs.bitcoin.HDNode.fromBase58(rootKeyBase58, network);
    }

    function calcBip32RootKeyFromBase58GRS(rootKeyBase58) {
        // try parsing with various segwit network params since this extended
        // key may be from any one of them.
        if (networkHasSegwit()) {
            var n = network;
            if ("baseNetwork" in n) {
                n = libs.bitcoin.networks[n.baseNetwork];
            }
            // try parsing using base network params
            try {
                bip32RootKey = libs.groestlcoinjs.HDNode.fromBase58(rootKeyBase58, n);
                return;
            }
            catch (e) {}
            // try parsing using p2wpkh params
            if ("p2wpkh" in n) {
                try {
                    bip32RootKey = libs.groestlcoinjs.HDNode.fromBase58(rootKeyBase58, n.p2wpkh);
                    return;
                }
                catch (e) {}
            }
            // try parsing using p2wpkh-in-p2sh network params
            if ("p2wpkhInP2sh" in n) {
                try {
                    bip32RootKey = libs.groestlcoinjs.HDNode.fromBase58(rootKeyBase58, n.p2wpkhInP2sh);
                    return;
                }
                catch (e) {}
            }
        }
        // try the network params as currently specified
        bip32RootKey = libs.groestlcoinjs.HDNode.fromBase58(rootKeyBase58, network);
    }

    function calcBip32ExtendedKey(path) {
        // Check there's a root key to derive from
        if (!bip32RootKey) {
            return bip32RootKey;
        }
        var extendedKey = bip32RootKey;
        // Derive the key from the path
        var pathBits = path.split("/");
        for (var i=0; i<pathBits.length; i++) {
            var bit = pathBits[i];
            var index = parseInt(bit);
            if (isNaN(index)) {
                continue;
            }
            var hardened = bit[bit.length-1] == "'";
            var isPriv = !(extendedKey.isNeutered());
            var invalidDerivationPath = hardened && !isPriv;
            if (invalidDerivationPath) {
                extendedKey = null;
            }
            else if (hardened) {
                extendedKey = extendedKey.deriveHardened(index);
            }
            else {
                extendedKey = extendedKey.derive(index);
            }
        }
        return extendedKey;
    }

    function showValidationError(errorText) {
        DOM.feedback
            .text(errorText)
            .show();
    }

    function hideValidationError() {
        DOM.feedback
            .text("")
            .hide();
    }

    function findPhraseErrors(phrase) {
        // Preprocess the words
        phrase = mnemonic.normalizeString(phrase);
        var words = phraseToWordArray(phrase);
        // Detect blank phrase
        if (words.length == 0) {
            return "Blank mnemonic";
        }
        // Check each word
        for (var i=0; i<words.length; i++) {
            var word = words[i];
            var language = getLanguage();
            if (WORDLISTS[language].indexOf(word) == -1) {
                console.log("Finding closest match to " + word);
                var nearestWord = findNearestWord(word);
                return word + " not in wordlist, did you mean " + nearestWord + "?";
            }
        }
        // Check the words are valid
        var properPhrase = wordArrayToPhrase(words);
        var isValid = mnemonic.check(properPhrase);
        if (!isValid) {
            return "Invalid mnemonic";
        }
        return false;
    }

    function validateRootKey(rootKeyBase58) {
        if(isGRS())
            return validateRootKeyGRS(rootKeyBase58);

        // try various segwit network params since this extended key may be from
        // any one of them.
        if (networkHasSegwit()) {
            var n = network;
            if ("baseNetwork" in n) {
                n = libs.bitcoin.networks[n.baseNetwork];
            }
            // try parsing using base network params
            try {
                libs.bitcoin.HDNode.fromBase58(rootKeyBase58, n);
                return "";
            }
            catch (e) {}
            // try parsing using p2wpkh params
            if ("p2wpkh" in n) {
                try {
                    libs.bitcoin.HDNode.fromBase58(rootKeyBase58, n.p2wpkh);
                    return "";
                }
                catch (e) {}
            }
            // try parsing using p2wpkh-in-p2sh network params
            if ("p2wpkhInP2sh" in n) {
                try {
                    libs.bitcoin.HDNode.fromBase58(rootKeyBase58, n.p2wpkhInP2sh);
                    return "";
                }
                catch (e) {}
            }
            // try parsing using p2wsh network params
            if ("p2wsh" in n) {
                try {
                    libs.bitcoin.HDNode.fromBase58(rootKeyBase58, n.p2wsh);
                    return "";
                }
                catch (e) {}
            }
            // try parsing using p2wsh-in-p2sh network params
            if ("p2wshInP2sh" in n) {
                try {
                    libs.bitcoin.HDNode.fromBase58(rootKeyBase58, n.p2wshInP2sh);
                    return "";
                }
                catch (e) {}
            }
        }
        // try the network params as currently specified
        try {
            libs.bitcoin.HDNode.fromBase58(rootKeyBase58, network);
        }
        catch (e) {
            return "Invalid root key";
        }
        return "";
    }

    function validateRootKeyGRS(rootKeyBase58) {
        // try various segwit network params since this extended key may be from
        // any one of them.
        if (networkHasSegwit()) {
            var n = network;
            if ("baseNetwork" in n) {
                n = libs.bitcoin.networks[n.baseNetwork];
            }
            // try parsing using base network params
            try {
                libs.groestlcoinjs.HDNode.fromBase58(rootKeyBase58, n);
                return "";
            }
            catch (e) {}
            // try parsing using p2wpkh params
            if ("p2wpkh" in n) {
                try {
                    libs.groestlcoinjs.HDNode.fromBase58(rootKeyBase58, n.p2wpkh);
                    return "";
                }
                catch (e) {}
            }
            // try parsing using p2wpkh-in-p2sh network params
            if ("p2wpkhInP2sh" in n) {
                try {
                    libs.groestlcoinjs.HDNode.fromBase58(rootKeyBase58, n.p2wpkhInP2sh);
                    return "";
                }
                catch (e) {}
            }
        }
        // try the network params as currently specified
        try {
            libs.groestlcoinjs.HDNode.fromBase58(rootKeyBase58, network);
        }
        catch (e) {
            return "Invalid root key";
        }
        return "";
    }

    function getDerivationPath() {
        if (bip44TabSelected()) {
            var purpose = parseIntNoNaN(DOM.bip44purpose.val(), 44);
            var coin = parseIntNoNaN(DOM.bip44coin.val(), 0);
            var account = parseIntNoNaN(DOM.bip44account.val(), 0);
            var change = parseIntNoNaN(DOM.bip44change.val(), 0);
            var path = "m/";
            path += purpose + "'/";
            path += coin + "'/";
            path += account + "'/";
            path += change;
            DOM.bip44path.val(path);
            var derivationPath = DOM.bip44path.val();
            console.log("Using derivation path from BIP44 tab: " + derivationPath);
            return derivationPath;
        }
        else if (bip49TabSelected()) {
            var purpose = parseIntNoNaN(DOM.bip49purpose.val(), 49);
            var coin = parseIntNoNaN(DOM.bip49coin.val(), 0);
            var account = parseIntNoNaN(DOM.bip49account.val(), 0);
            var change = parseIntNoNaN(DOM.bip49change.val(), 0);
            var path = "m/";
            path += purpose + "'/";
            path += coin + "'/";
            path += account + "'/";
            path += change;
            DOM.bip49path.val(path);
            var derivationPath = DOM.bip49path.val();
            console.log("Using derivation path from BIP49 tab: " + derivationPath);
            return derivationPath;
        }
        else if (bip84TabSelected()) {
            var purpose = parseIntNoNaN(DOM.bip84purpose.val(), 84);
            var coin = parseIntNoNaN(DOM.bip84coin.val(), 0);
            var account = parseIntNoNaN(DOM.bip84account.val(), 0);
            var change = parseIntNoNaN(DOM.bip84change.val(), 0);
            var path = "m/";
            path += purpose + "'/";
            path += coin + "'/";
            path += account + "'/";
            path += change;
            DOM.bip84path.val(path);
            var derivationPath = DOM.bip84path.val();
            console.log("Using derivation path from BIP84 tab: " + derivationPath);
            return derivationPath;
        }
        else if (bip32TabSelected()) {
            var derivationPath = DOM.bip32path.val();
            console.log("Using derivation path from BIP32 tab: " + derivationPath);
            return derivationPath;
        }
        else if (bip141TabSelected()) {
            var derivationPath = DOM.bip141path.val();
            console.log("Using derivation path from BIP141 tab: " + derivationPath);
            return derivationPath;
        }
        else {
            console.log("Unknown derivation path");
        }
    }

    function findDerivationPathErrors(path) {
        // TODO is not perfect but is better than nothing
        // Inspired by
        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#test-vectors
        // and
        // https://github.com/bitcoin/bips/blob/master/bip-0032.mediawiki#extended-keys
        var maxDepth = 255; // TODO verify this!!
        var maxIndexValue = Math.pow(2, 31); // TODO verify this!!
        if (path[0] != "m") {
            return "First character must be 'm'";
        }
        if (path.length > 1) {
            if (path[1] != "/") {
                return "Separator must be '/'";
            }
            var indexes = path.split("/");
            if (indexes.length > maxDepth) {
                return "Derivation depth is " + indexes.length + ", must be less than " + maxDepth;
            }
            for (var depth = 1; depth<indexes.length; depth++) {
                var index = indexes[depth];
                var invalidChars = index.replace(/^[0-9]+'?$/g, "")
                if (invalidChars.length > 0) {
                    return "Invalid characters " + invalidChars + " found at depth " + depth;
                }
                var indexValue = parseInt(index.replace("'", ""));
                if (isNaN(depth)) {
                    return "Invalid number at depth " + depth;
                }
                if (indexValue > maxIndexValue) {
                    return "Value of " + indexValue + " at depth " + depth + " must be less than " + maxIndexValue;
                }
            }
        }
        // Check root key exists or else derivation path is useless!
        if (!bip32RootKey) {
            return "No root key";
        }
        // Check no hardened derivation path when using xpub keys
        var hardenedPath = path.indexOf("'") > -1;
        var hardenedAddresses = bip32TabSelected() && DOM.hardenedAddresses.prop("checked");
        var hardened = hardenedPath || hardenedAddresses;
        var isXpubkey = bip32RootKey.isNeutered();
        if (hardened && isXpubkey) {
            return "Hardened derivation path is invalid with xpub key";
        }
        return false;
    }

    function isGRS() {
        return networks[DOM.network.val()].name == "GRS - Groestlcoin" || networks[DOM.network.val()].name == "GRS - Groestlcoin Testnet";
    }

    function isELA() {
        return networks[DOM.network.val()].name == "ELA - Elastos"
    }

    function displayBip44Info() {
        // Get the derivation path for the account
        var purpose = parseIntNoNaN(DOM.bip44purpose.val(), 44);
        var coin = parseIntNoNaN(DOM.bip44coin.val(), 0);
        var account = parseIntNoNaN(DOM.bip44account.val(), 0);
        var path = "m/";
        path += purpose + "'/";
        path += coin + "'/";
        path += account + "'/";
        // Calculate the account extended keys
        var accountExtendedKey = calcBip32ExtendedKey(path);
        var accountXprv = accountExtendedKey.toBase58();
        var accountXpub = accountExtendedKey.neutered().toBase58();

        // Display the extended keys
        DOM.bip44accountXprv.val(accountXprv);
        DOM.bip44accountXpub.val(accountXpub);

        if (isELA()) {
            displayBip44InfoForELA();
        }
    }

    function displayBip49Info() {
        // Get the derivation path for the account
        var purpose = parseIntNoNaN(DOM.bip49purpose.val(), 49);
        var coin = parseIntNoNaN(DOM.bip49coin.val(), 0);
        var account = parseIntNoNaN(DOM.bip49account.val(), 0);
        var path = "m/";
        path += purpose + "'/";
        path += coin + "'/";
        path += account + "'/";
        // Calculate the account extended keys
        var accountExtendedKey = calcBip32ExtendedKey(path);
        var accountXprv = accountExtendedKey.toBase58();
        var accountXpub = accountExtendedKey.neutered().toBase58();
        // Display the extended keys
        DOM.bip49accountXprv.val(accountXprv);
        DOM.bip49accountXpub.val(accountXpub);
    }

    function displayBip84Info() {
        // Get the derivation path for the account
        var purpose = parseIntNoNaN(DOM.bip84purpose.val(), 84);
        var coin = parseIntNoNaN(DOM.bip84coin.val(), 0);
        var account = parseIntNoNaN(DOM.bip84account.val(), 0);
        var path = "m/";
        path += purpose + "'/";
        path += coin + "'/";
        path += account + "'/";
        // Calculate the account extended keys
        var accountExtendedKey = calcBip32ExtendedKey(path);
        var accountXprv = accountExtendedKey.toBase58();
        var accountXpub = accountExtendedKey.neutered().toBase58();
        // Display the extended keys
        DOM.bip84accountXprv.val(accountXprv);
        DOM.bip84accountXpub.val(accountXpub);
    }

    function displayBip32Info() {
        // Display the key
        DOM.seed.val(seed);
        var rootKey = bip32RootKey.toBase58();
        DOM.rootKey.val(rootKey);
        var xprvkeyB58 = "NA";
        if (!bip32ExtendedKey.isNeutered()) {
            xprvkeyB58 = bip32ExtendedKey.toBase58();
        }
        var extendedPrivKey = xprvkeyB58;
        DOM.extendedPrivKey.val(extendedPrivKey);
        var extendedPubKey = bip32ExtendedKey.neutered().toBase58();
        DOM.extendedPubKey.val(extendedPubKey);
        // Display the addresses and privkeys
        clearAddressesList();
        var initialAddressCount = parseInt(DOM.rowsToAdd.val());
        displayAddresses(0, initialAddressCount);

        if (isELA()) {
            displayBip32InfoForELA();
        }
    }

    function displayAddresses(start, total) {
        generationProcesses.push(new (function() {

            var rows = [];

            this.stop = function() {
                for (var i=0; i<rows.length; i++) {
                    rows[i].shouldGenerate = false;
                }
                hidePending();
            }

            for (var i=0; i<total; i++) {
                var index = i + start;
                var isLast = i == total - 1;
                rows.push(new TableRow(index, isLast));
            }

        })());
    }

    function segwitSelected() {
        return bip49TabSelected() || bip84TabSelected() || bip141TabSelected();
    }

    function p2wpkhSelected() {
        return bip84TabSelected() ||
                bip141TabSelected() && DOM.bip141semantics.val() == "p2wpkh";
    }

    function p2wpkhInP2shSelected() {
        return bip49TabSelected() ||
            (bip141TabSelected() && DOM.bip141semantics.val() == "p2wpkh-p2sh");
    }

    function p2wshSelected() {
        return bip141TabSelected() && DOM.bip141semantics.val() == "p2wsh";
    }

    function p2wshInP2shSelected() {
        return (bip141TabSelected() && DOM.bip141semantics.val() == "p2wsh-p2sh");
    }

    function TableRow(index, isLast) {

        var self = this;
        this.shouldGenerate = true;
        var useHardenedAddresses = DOM.hardenedAddresses.prop("checked");
        var useBip38 = DOM.useBip38.prop("checked");
        var bip38password = DOM.bip38Password.val();
        var isSegwit = segwitSelected();
        var segwitAvailable = networkHasSegwit();
        var isP2wpkh = p2wpkhSelected();
        var isP2wpkhInP2sh = p2wpkhInP2shSelected();
        var isP2wsh = p2wshSelected();
        var isP2wshInP2sh = p2wshInP2shSelected();

        function init() {
            calculateValues();
        }

        function calculateValues() {
            setTimeout(function() {
                if (!self.shouldGenerate) {
                    return;
                }
                // derive HDkey for this row of the table
                var key = "NA";
                if (useHardenedAddresses) {
                    key = bip32ExtendedKey.deriveHardened(index);
                }
                else {
                    key = bip32ExtendedKey.derive(index);
                }
                // bip38 requires uncompressed keys
                // see https://github.com/iancoleman/bip39/issues/140#issuecomment-352164035
                var keyPair = key.keyPair;
                var useUncompressed = useBip38;
                if (useUncompressed) {
                    keyPair = new libs.bitcoin.ECPair(keyPair.d, null, { network: network, compressed: false });
                    if(isGRS())
                        keyPair = new libs.groestlcoinjs.ECPair(keyPair.d, null, { network: network, compressed: false });

                }
                // get address
                var address = keyPair.getAddress().toString();
                // get privkey
                var hasPrivkey = !key.isNeutered();
                var privkey = "NA";
                if (hasPrivkey) {
                    privkey = keyPair.toWIF();
                    // BIP38 encode private key if required
                    if (useBip38) {
                        if(isGRS())
                            privkey = libs.groestlcoinjsBip38.encrypt(keyPair.d.toBuffer(), false, bip38password, function(p) {
                                console.log("Progressed " + p.percent.toFixed(1) + "% for index " + index);
                            }, null, networks[DOM.network.val()].name.includes("Testnet"));
                        else
                            privkey = libs.bip38.encrypt(keyPair.d.toBuffer(), false, bip38password, function(p) {
                                console.log("Progressed " + p.percent.toFixed(1) + "% for index " + index);
                            });
                    }
                }
                // get pubkey
                var pubkey = keyPair.getPublicKeyBuffer().toString('hex');
                var indexText = getDerivationPath() + "/" + index;
                if (useHardenedAddresses) {
                    indexText = indexText + "'";
                }
                // Ethereum values are different
                if (networkIsEthereum()) {
                    var pubkeyBuffer = keyPair.getPublicKeyBuffer();
                    var ethPubkey = libs.ethUtil.importPublic(pubkeyBuffer);
                    var addressBuffer = libs.ethUtil.publicToAddress(ethPubkey);
                    var hexAddress = addressBuffer.toString('hex');
                    var checksumAddress = libs.ethUtil.toChecksumAddress(hexAddress);
                    address = libs.ethUtil.addHexPrefix(checksumAddress);
                    pubkey = libs.ethUtil.addHexPrefix(pubkey);
                    if (hasPrivkey) {
                        privkey = libs.ethUtil.bufferToHex(keyPair.d.toBuffer(32));
                    }
                }
                //TRX is different
                if (networks[DOM.network.val()].name == "TRX - Tron") {
                    keyPair = new libs.bitcoin.ECPair(keyPair.d, null, { network: network, compressed: false });
                    var pubkeyBuffer = keyPair.getPublicKeyBuffer();
                    var ethPubkey = libs.ethUtil.importPublic(pubkeyBuffer);
                    var addressBuffer = libs.ethUtil.publicToAddress(ethPubkey);
                    address = libs.bitcoin.address.toBase58Check(addressBuffer, 0x41);
                    if (hasPrivkey) {
                        privkey = keyPair.d.toBuffer().toString('hex');
                    }
                }

                // RSK values are different
                if (networkIsRsk()) {
                    var pubkeyBuffer = keyPair.getPublicKeyBuffer();
                    var ethPubkey = libs.ethUtil.importPublic(pubkeyBuffer);
                    var addressBuffer = libs.ethUtil.publicToAddress(ethPubkey);
                    var hexAddress = addressBuffer.toString('hex');
                    // Use chainId based on selected network
                    // Ref: https://developers.rsk.co/rsk/architecture/account-based/#chainid
                    var chainId;
                    var rskNetworkName = networks[DOM.network.val()].name;
                    switch (rskNetworkName) {
                        case "R-BTC - RSK":
                            chainId = 30;
                            break;
                        case "tR-BTC - RSK Testnet":
                            chainId = 31;
                            break;
                        default:
                            chainId = null;
                    }
                    var checksumAddress = toChecksumAddressForRsk(hexAddress, chainId);
                    address = libs.ethUtil.addHexPrefix(checksumAddress);
                    pubkey = libs.ethUtil.addHexPrefix(pubkey);
                    if (hasPrivkey) {
                        privkey = libs.ethUtil.bufferToHex(keyPair.d.toBuffer());
                    }
                }

                // Handshake values are different
                if (networks[DOM.network.val()].name == "HNS - Handshake") {
                    var ring = libs.handshake.KeyRing.fromPublic(keyPair.getPublicKeyBuffer())
                    address = ring.getAddress().toString();
                }

                // Stellar is different
                if (networks[DOM.network.val()].name == "XLM - Stellar") {
                    var purpose = parseIntNoNaN(DOM.bip44purpose.val(), 44);
                    var coin = parseIntNoNaN(DOM.bip44coin.val(), 0);
                    var path = "m/";
                        path += purpose + "'/";
                        path += coin + "'/" + index + "'";
                    var keypair = libs.stellarUtil.getKeypair(path, seed);
                    indexText = path;
                    privkey = keypair.secret();
                    pubkey = address = keypair.publicKey();
                }

                // Nano currency
                if (networks[DOM.network.val()].name == "NANO - Nano") {
                    var nanoKeypair = libs.nanoUtil.getKeypair(index, seed);
                    privkey = nanoKeypair.privKey;
                    pubkey = nanoKeypair.pubKey;
                    address = nanoKeypair.address;
                }

                if ((networks[DOM.network.val()].name == "NAS - Nebulas")) {
                    var privKeyBuffer = keyPair.d.toBuffer(32);
                    var nebulasAccount = libs.nebulas.Account.NewAccount();
                    nebulasAccount.setPrivateKey(privKeyBuffer);
                    address = nebulasAccount.getAddressString();
                    privkey = nebulasAccount.getPrivateKeyString();
                    pubkey = nebulasAccount.getPublicKeyString();
                }
                // Ripple values are different
                if (networks[DOM.network.val()].name == "XRP - Ripple") {
                    privkey = convertRipplePriv(privkey);
                    address = convertRippleAdrr(address);
                }
                // Jingtum values are different
                if (networks[DOM.network.val()].name == "SWTC - Jingtum") {
                    privkey = convertJingtumPriv(privkey);
                    address = convertJingtumAdrr(address);
                }
                // CasinoCoin values are different
                if (networks[DOM.network.val()].name == "CSC - CasinoCoin") {
                    privkey = convertCasinoCoinPriv(privkey);
                    address = convertCasinoCoinAdrr(address);
                }
                // Bitcoin Cash address format may vary
                if (networks[DOM.network.val()].name == "BCH - Bitcoin Cash") {
                    var bchAddrType = DOM.bitcoinCashAddressType.filter(":checked").val();
                    if (bchAddrType == "cashaddr") {
                        address = libs.bchaddr.toCashAddress(address);
                    }
                    else if (bchAddrType == "bitpay") {
                        address = libs.bchaddr.toBitpayAddress(address);
                    }
                }
                 // Bitcoin Cash address format may vary
                 if (networks[DOM.network.val()].name == "SLP - Simple Ledger Protocol") {
                     var bchAddrType = DOM.bitcoinCashAddressType.filter(":checked").val();
                     if (bchAddrType == "cashaddr") {
                         address = libs.bchaddrSlp.toSlpAddress(address);
                     }
                 }

                // ZooBC address format may vary
                if (networks[DOM.network.val()].name == "ZBC - ZooBlockchain") {

                    var purpose = parseIntNoNaN(DOM.bip44purpose.val(), 44);
                    var coin = parseIntNoNaN(DOM.bip44coin.val(), 0);
                    var path = "m/";
                        path += purpose + "'/";
                        path += coin + "'/" + index + "'";
                    var result = libs.zoobcUtil.getKeypair(path, seed);

                    let publicKey = result.pubKey.slice(1, 33);
                    let privateKey = result.key;

                    privkey = privateKey.toString('hex');
                    pubkey = publicKey.toString('hex');

                    indexText = path;
                    address = libs.zoobcUtil.getZBCAddress(publicKey, 'ZBC');
                }

                // Segwit addresses are different
                if (isSegwit) {
                    if (!segwitAvailable) {
                        return;
                    }
                    if (isP2wpkh) {
                        var keyhash = libs.bitcoin.crypto.hash160(key.getPublicKeyBuffer());
                        var scriptpubkey = libs.bitcoin.script.witnessPubKeyHash.output.encode(keyhash);
                        address = libs.bitcoin.address.fromOutputScript(scriptpubkey, network)
                    }
                    else if (isP2wpkhInP2sh) {
                        var keyhash = libs.bitcoin.crypto.hash160(key.getPublicKeyBuffer());
                        var scriptsig = libs.bitcoin.script.witnessPubKeyHash.output.encode(keyhash);
                        var addressbytes = libs.bitcoin.crypto.hash160(scriptsig);
                        var scriptpubkey = libs.bitcoin.script.scriptHash.output.encode(addressbytes);
                        address = libs.bitcoin.address.fromOutputScript(scriptpubkey, network)
                    }
                    else if (isP2wsh) {
                        // https://github.com/libs.bitcoinjs-lib/blob/v3.3.2/test/integration/addresses.js#L71
                        // This is a 1-of-1
                        var witnessScript = libs.bitcoin.script.multisig.output.encode(1, [key.getPublicKeyBuffer()]);
                        var scriptPubKey = libs.bitcoin.script.witnessScriptHash.output.encode(libs.bitcoin.crypto.sha256(witnessScript));
                        address = libs.bitcoin.address.fromOutputScript(scriptPubKey, network);
                    }
                    else if (isP2wshInP2sh) {
                        // https://github.com/libs.bitcoinjs-lib/blob/v3.3.2/test/integration/transactions.js#L183
                        // This is a 1-of-1
                        var witnessScript = libs.bitcoin.script.multisig.output.encode(1, [key.getPublicKeyBuffer()]);
                        var redeemScript = libs.bitcoin.script.witnessScriptHash.output.encode(libs.bitcoin.crypto.sha256(witnessScript));
                        var scriptPubKey = libs.bitcoin.script.scriptHash.output.encode(libs.bitcoin.crypto.hash160(redeemScript));
                        address = libs.bitcoin.address.fromOutputScript(scriptPubKey, network)
                    }
                }

                if ((networks[DOM.network.val()].name == "CRW - Crown")) {
                    address = libs.bitcoin.networks.crown.toNewAddress(address);
                }

              if (networks[DOM.network.val()].name == "EOS - EOSIO") {
                    address = ""
                    pubkey = EOSbufferToPublic(keyPair.getPublicKeyBuffer());
                    privkey = EOSbufferToPrivate(keyPair.d.toBuffer(32));
                }

                if (networks[DOM.network.val()].name == "FIO - Foundation for Interwallet Operability") {
                    address = ""
                    pubkey = FIObufferToPublic(keyPair.getPublicKeyBuffer());
                    privkey = FIObufferToPrivate(keyPair.d.toBuffer(32));
                }

                if (networks[DOM.network.val()].name == "ATOM - Cosmos Hub") {
                    const hrp = "cosmos";
                    address = CosmosBufferToAddress(keyPair.getPublicKeyBuffer(), hrp);
                    pubkey = CosmosBufferToPublic(keyPair.getPublicKeyBuffer(), hrp);
                    privkey = keyPair.d.toBuffer().toString("base64");
                }

                if (networks[DOM.network.val()].name == "RUNE - THORChain") {
                     const hrp = "thor";
                     address = CosmosBufferToAddress(keyPair.getPublicKeyBuffer(), hrp);
                     pubkey = keyPair.getPublicKeyBuffer().toString("hex");
                     privkey = keyPair.d.toBuffer().toString("hex");
                }

                if (networks[DOM.network.val()].name == "XWC - Whitecoin"){
                    address = XWCbufferToAddress(keyPair.getPublicKeyBuffer());
                    pubkey = XWCbufferToPublic(keyPair.getPublicKeyBuffer());
                    privkey = XWCbufferToPrivate(keyPair.d.toBuffer(32));
                }

                if (networks[DOM.network.val()].name == "LUNA - Terra") {
                    const hrp = "terra";
                    address = CosmosBufferToAddress(keyPair.getPublicKeyBuffer(), hrp);
                    pubkey = keyPair.getPublicKeyBuffer().toString("hex");
                    privkey = keyPair.d.toBuffer().toString("hex");
                }

                if (networks[DOM.network.val()].name == "IOV - Starname") {
                  const hrp = "star";
                  address = CosmosBufferToAddress(keyPair.getPublicKeyBuffer(), hrp);
                  pubkey = CosmosBufferToPublic(keyPair.getPublicKeyBuffer(), hrp);
                  privkey = keyPair.d.toBuffer().toString("base64");
                }

              //Groestlcoin Addresses are different
                if(isGRS()) {

                    if (isSegwit) {
                        if (!segwitAvailable) {
                            return;
                        }
                        if (isP2wpkh) {
                            address = libs.groestlcoinjs.address.fromOutputScript(scriptpubkey, network)
                        }
                        else if (isP2wpkhInP2sh) {
                            address = libs.groestlcoinjs.address.fromOutputScript(scriptpubkey, network)
                        }
                    }
                    //non-segwit addresses are handled by using groestlcoinjs for bip32RootKey
                }

                if (isELA()) {
                    let elaAddress = calcAddressForELA(
                        seed,
                        parseIntNoNaN(DOM.bip44coin.val(), 0),
                        parseIntNoNaN(DOM.bip44account.val(), 0),
                        parseIntNoNaN(DOM.bip44change.val(), 0),
                        index
                    );
                    address = elaAddress.address;
                    privkey = elaAddress.privateKey;
                    pubkey = elaAddress.publicKey;
                }

                addAddressToList(indexText, address, pubkey, privkey);
                if (isLast) {
                    hidePending();
                    updateCsv();
                }
            }, 50)
        }

        init();

    }

    function showMore() {
        var rowsToAdd = parseInt(DOM.rowsToAdd.val());
        if (isNaN(rowsToAdd)) {
            rowsToAdd = 20;
            DOM.rowsToAdd.val("20");
        }
        var start = parseInt(DOM.moreRowsStartIndex.val())
        if (isNaN(start)) {
            start = lastIndexInTable() + 1;
        }
        else {
            var newStart = start + rowsToAdd;
            DOM.moreRowsStartIndex.val(newStart);
        }
        if (rowsToAdd > 200) {
            var msg = "Generating " + rowsToAdd + " rows could take a while. ";
            msg += "Do you want to continue?";
            if (!confirm(msg)) {
                return;
            }
        }
        displayAddresses(start, rowsToAdd);
    }

    function clearDisplay() {
        clearAddressesList();
        clearKeys();
        hideValidationError();
    }

    function clearAddressesList() {
        DOM.addresses.empty();
        DOM.csv.val("");
        stopGenerating();
    }

    function stopGenerating() {
        while (generationProcesses.length > 0) {
            var generation = generationProcesses.shift();
            generation.stop();
        }
    }

    function clearKeys() {
        clearRootKey();
        clearDerivedKeys();
    }

    function clearRootKey() {
        DOM.rootKey.val("");
    }

    function clearDerivedKeys() {
        DOM.extendedPrivKey.val("");
        DOM.extendedPubKey.val("");
        DOM.bip44accountXprv.val("");
        DOM.bip44accountXpub.val("");
    }

    function addAddressToList(indexText, address, pubkey, privkey) {
        var row = $(addressRowTemplate.html());
        // Elements
        var indexCell = row.find(".index span");
        var addressCell = row.find(".address span");
        var pubkeyCell = row.find(".pubkey span");
        var privkeyCell = row.find(".privkey span");
        // Content
        indexCell.text(indexText);
        addressCell.text(address);
        pubkeyCell.text(pubkey);
        privkeyCell.text(privkey);
        // Visibility
        if (!showIndex) {
            indexCell.addClass("invisible");
        }
        if (!showAddress) {
            addressCell.addClass("invisible");
        }
        if (!showPubKey) {
            pubkeyCell.addClass("invisible");
        }
        if (!showPrivKey) {
            privkeyCell.addClass("invisible");
        }
        DOM.addresses.append(row);
        var rowShowQrEls = row.find("[data-show-qr]");
        setQrEvents(rowShowQrEls);
    }

    function hasStrongRandom() {
        return 'crypto' in window && window['crypto'] !== null;
    }

    function disableForms() {
        $("form").on("submit", function(e) {
            e.preventDefault();
        });
    }

    function parseIntNoNaN(val, defaultVal) {
        var v = parseInt(val);
        if (isNaN(v)) {
            return defaultVal;
        }
        return v;
    }

    function showPending() {
        DOM.feedback
            .text("Calculating...")
            .show();
    }

    function findNearestWord(word) {
        var language = getLanguage();
        var words = WORDLISTS[language];
        var minDistance = 99;
        var closestWord = words[0];
        for (var i=0; i<words.length; i++) {
            var comparedTo = words[i];
            if (comparedTo.indexOf(word) == 0) {
                return comparedTo;
            }
            var distance = libs.levenshtein.get(word, comparedTo);
            if (distance < minDistance) {
                closestWord = comparedTo;
                minDistance = distance;
            }
        }
        return closestWord;
    }

    function hidePending() {
        DOM.feedback
            .text("")
            .hide();
    }

    function populateNetworkSelect() {
        for (var i=0; i<networks.length; i++) {
            var network = networks[i];
            var option = $("<option>");
            option.attr("value", i);
            option.text(network.name);
            if (network.name == "BTC - Bitcoin") {
                option.prop("selected", true);
            }
            DOM.phraseNetwork.append(option);
        }
    }

    function populateClientSelect() {
        for (var i=0; i<clients.length; i++) {
            var client = clients[i];
            var option = $("<option>");
            option.attr("value", i);
            option.text(client.name);
            DOM.bip32Client.append(option);
        }
    }

    function getLanguage() {
        var defaultLanguage = "english";
        // Try to get from existing phrase
        var language = getLanguageFromPhrase();
        // Try to get from url if not from phrase
        if (language.length == 0) {
            language = getLanguageFromUrl();
        }
        // Default to English if no other option
        if (language.length == 0) {
            language = defaultLanguage;
        }
        return language;
    }

    function getLanguageFromPhrase(phrase) {
        // Check if how many words from existing phrase match a language.
        var language = "";
        if (!phrase) {
            phrase = DOM.phrase.val();
        }
        if (phrase.length > 0) {
            var words = phraseToWordArray(phrase);
            var languageMatches = {};
            for (l in WORDLISTS) {
                // Track how many words match in this language
                languageMatches[l] = 0;
                for (var i=0; i<words.length; i++) {
                    var wordInLanguage = WORDLISTS[l].indexOf(words[i]) > -1;
                    if (wordInLanguage) {
                        languageMatches[l]++;
                    }
                }
                // Find languages with most word matches.
                // This is made difficult due to commonalities between Chinese
                // simplified vs traditional.
                var mostMatches = 0;
                var mostMatchedLanguages = [];
                for (var l in languageMatches) {
                    var numMatches = languageMatches[l];
                    if (numMatches > mostMatches) {
                        mostMatches = numMatches;
                        mostMatchedLanguages = [l];
                    }
                    else if (numMatches == mostMatches) {
                        mostMatchedLanguages.push(l);
                    }
                }
            }
            if (mostMatchedLanguages.length > 0) {
                // Use first language and warn if multiple detected
                language = mostMatchedLanguages[0];
                if (mostMatchedLanguages.length > 1) {
                    console.warn("Multiple possible languages");
                    console.warn(mostMatchedLanguages);
                }
            }
        }
        return language;
    }

    function getLanguageFromUrl() {
        for (var language in WORDLISTS) {
            if (window.location.hash.indexOf(language) > -1) {
                return language;
            }
        }
        return "";
    }

    function setMnemonicLanguage() {
        var language = getLanguage();
        // Load the bip39 mnemonic generator for this language if required
        if (!(language in mnemonics)) {
            mnemonics[language] = new Mnemonic(language);
        }
        mnemonic = mnemonics[language];
    }

    function convertPhraseToNewLanguage() {
        var oldLanguage = getLanguageFromPhrase();
        var newLanguage = getLanguageFromUrl();
        var oldPhrase = DOM.phrase.val();
        var oldWords = phraseToWordArray(oldPhrase);
        var newWords = [];
        for (var i=0; i<oldWords.length; i++) {
            var oldWord = oldWords[i];
            var index = WORDLISTS[oldLanguage].indexOf(oldWord);
            var newWord = WORDLISTS[newLanguage][index];
            newWords.push(newWord);
        }
        newPhrase = wordArrayToPhrase(newWords);
        return newPhrase;
    }

    // TODO look at jsbip39 - mnemonic.splitWords
    function phraseToWordArray(phrase) {
        var words = phrase.split(/\s/g);
        var noBlanks = [];
        for (var i=0; i<words.length; i++) {
            var word = words[i];
            if (word.length > 0) {
                noBlanks.push(word);
            }
        }
        return noBlanks;
    }

    // TODO look at jsbip39 - mnemonic.joinWords
    function wordArrayToPhrase(words) {
        var phrase = words.join(" ");
        var language = getLanguageFromPhrase(phrase);
        if (language == "japanese") {
            phrase = words.join("\u3000");
        }
        return phrase;
    }

    function writeSplitPhrase(phrase) {
        var wordCount = phrase.split(/\s/g).length;
        var left=[];
        for (var i=0;i<wordCount;i++) left.push(i);
        var group=[[],[],[]],
            groupI=-1;
        var seed = Math.abs(sjcl.hash.sha256.hash(phrase)[0])% 2147483647;
        while (left.length>0) {
            groupI=(groupI+1)%3;
            seed = seed * 16807 % 2147483647;
            var selected=Math.floor(left.length*(seed - 1) / 2147483646);
            group[groupI].push(left[selected]);
            left.splice(selected,1);
        }
        var cards=[phrase.split(/\s/g),phrase.split(/\s/g),phrase.split(/\s/g)];
        for (var i=0;i<3;i++) {
            for (var ii=0;ii<wordCount/3;ii++) cards[i][group[i][ii]]='XXXX';
            cards[i]='Card '+(i+1)+': '+wordArrayToPhrase(cards[i]);
        }
        DOM.phraseSplit.val(cards.join("\r\n"));
        var triesPerSecond=10000000000;
        var hackTime=Math.pow(2,wordCount*10/3)/triesPerSecond;
        var displayRedText = false;
        if (hackTime<1) {
            hackTime="<1 second";
            displayRedText = true;
        } else if (hackTime<86400) {
            hackTime=Math.floor(hackTime)+" seconds";
            displayRedText = true;
        } else if(hackTime<31557600) {
            hackTime=Math.floor(hackTime/86400)+" days";
            displayRedText = true;
        } else {
            hackTime=Math.floor(hackTime/31557600)+" years";
        }
        DOM.phraseSplitWarn.html("Time to hack with only one card: "+hackTime);
        if (displayRedText) {
            DOM.phraseSplitWarn.addClass("text-danger");
        } else {
            DOM.phraseSplitWarn.removeClass("text-danger");
        }
    }

    function isUsingOwnEntropy() {
        return DOM.useEntropy.prop("checked");
    }

    function setMnemonicFromEntropy() {
        clearEntropyFeedback();
        // Get entropy value
        var entropyStr = DOM.entropy.val();
        // Work out minimum base for entropy
        var entropy = null;
        if (entropyTypeAutoDetect) {
            entropy = Entropy.fromString(entropyStr);
        }
        else {
            let base = DOM.entropyTypeInputs.filter(":checked").val();
            entropy = Entropy.fromString(entropyStr, base);
        }
        if (entropy.binaryStr.length == 0) {
            return;
        }
        // Show entropy details
        showEntropyFeedback(entropy);
        // Use entropy hash if not using raw entropy
        var bits = entropy.binaryStr;
        var mnemonicLength = DOM.entropyMnemonicLength.val();
        if (mnemonicLength != "raw") {
            // Get bits by hashing entropy with SHA256
            var hash = sjcl.hash.sha256.hash(entropy.cleanStr);
            var hex = sjcl.codec.hex.fromBits(hash);
            bits = libs.BigInteger.BigInteger.parse(hex, 16).toString(2);
            while (bits.length % 256 != 0) {
                bits = "0" + bits;
            }
            // Truncate hash to suit number of words
            mnemonicLength = parseInt(mnemonicLength);
            var numberOfBits = 32 * mnemonicLength / 3;
            bits = bits.substring(0, numberOfBits);
            // show warning for weak entropy override
            if (mnemonicLength / 3 * 32 > entropy.binaryStr.length) {
                DOM.entropyWeakEntropyOverrideWarning.removeClass("hidden");
            }
            else {
                DOM.entropyWeakEntropyOverrideWarning.addClass("hidden");
            }
        }
        else {
            // hide warning for weak entropy override
            DOM.entropyWeakEntropyOverrideWarning.addClass("hidden");
        }
        // Discard trailing entropy
        var bitsToUse = Math.floor(bits.length / 32) * 32;
        var start = bits.length - bitsToUse;
        var binaryStr = bits.substring(start);
        // Convert entropy string to numeric array
        var entropyArr = [];
        for (var i=0; i<binaryStr.length / 8; i++) {
            var byteAsBits = binaryStr.substring(i*8, i*8+8);
            var entropyByte = parseInt(byteAsBits, 2);
            entropyArr.push(entropyByte)
        }
        // Convert entropy array to mnemonic
        var phrase = mnemonic.toMnemonic(entropyArr);
        // Set the mnemonic in the UI
        DOM.phrase.val(phrase);
        writeSplitPhrase(phrase);
        // Show the word indexes
        showWordIndexes();
        // Show the checksum
        showChecksum();
    }

    function clearEntropyFeedback() {
        DOM.entropyCrackTime.text("...");
        DOM.entropyType.text("");
        DOM.entropyWordCount.text("0");
        DOM.entropyEventCount.text("0");
        DOM.entropyBitsPerEvent.text("0");
        DOM.entropyBits.text("0");
        DOM.entropyFiltered.html("&nbsp;");
        DOM.entropyBinary.html("&nbsp;");
    }

    function showEntropyFeedback(entropy) {
        var numberOfBits = entropy.binaryStr.length;
        var timeToCrack = "unknown";
        try {
            var z = libs.zxcvbn(entropy.base.events.join(""));
            timeToCrack = z.crack_times_display.offline_fast_hashing_1e10_per_second;
            if (z.feedback.warning != "") {
                timeToCrack = timeToCrack + " - " + z.feedback.warning;
            };
        }
        catch (e) {
            console.log("Error detecting entropy strength with zxcvbn:");
            console.log(e);
        }
        var entropyTypeStr = getEntropyTypeStr(entropy);
        DOM.entropyTypeInputs.attr("checked", false);
        DOM.entropyTypeInputs.filter("[value='" + entropyTypeStr + "']").attr("checked", true);
        var wordCount = Math.floor(numberOfBits / 32) * 3;
        var bitsPerEvent = entropy.bitsPerEvent.toFixed(2);
        var spacedBinaryStr = addSpacesEveryElevenBits(entropy.binaryStr);
        DOM.entropyFiltered.html(entropy.cleanHtml);
        DOM.entropyType.text(entropyTypeStr);
        DOM.entropyCrackTime.text(timeToCrack);
        DOM.entropyEventCount.text(entropy.base.events.length);
        DOM.entropyBits.text(numberOfBits);
        DOM.entropyWordCount.text(wordCount);
        DOM.entropyBinary.text(spacedBinaryStr);
        DOM.entropyBitsPerEvent.text(bitsPerEvent);
        // detect and warn of filtering
        var rawNoSpaces = DOM.entropy.val().replace(/\s/g, "");
        var cleanNoSpaces = entropy.cleanStr.replace(/\s/g, "");
        var isFiltered = rawNoSpaces.length != cleanNoSpaces.length;
        if (isFiltered) {
            DOM.entropyFilterWarning.removeClass('hidden');
        }
        else {
            DOM.entropyFilterWarning.addClass('hidden');
        }
    }

    function getEntropyTypeStr(entropy) {
        var typeStr = entropy.base.str;
        // Add some detail if these are cards
        if (entropy.base.asInt == 52) {
            var cardDetail = []; // array of message strings
            // Detect duplicates
            var dupes = [];
            var dupeTracker = {};
            for (var i=0; i<entropy.base.events.length; i++) {
                var card = entropy.base.events[i];
                var cardUpper = card.toUpperCase();
                if (cardUpper in dupeTracker) {
                    dupes.push(card);
                }
                dupeTracker[cardUpper] = true;
            }
            if (dupes.length > 0) {
                var dupeWord = "duplicates";
                if (dupes.length == 1) {
                    dupeWord = "duplicate";
                }
                var msg = dupes.length + " " + dupeWord + ": " + dupes.slice(0,3).join(" ");
                if (dupes.length > 3) {
                    msg += "...";
                }
                cardDetail.push(msg);
            }
            // Detect full deck
            var uniqueCards = [];
            for (var uniqueCard in dupeTracker) {
                uniqueCards.push(uniqueCard);
            }
            if (uniqueCards.length == 52) {
                cardDetail.unshift("full deck");
            }
            // Detect missing cards
            var values = "A23456789TJQK";
            var suits = "CDHS";
            var missingCards = [];
            for (var i=0; i<suits.length; i++) {
                for (var j=0; j<values.length; j++) {
                    var card = values[j] + suits[i];
                    if (!(card in dupeTracker)) {
                        missingCards.push(card);
                    }
                }
            }
            // Display missing cards if six or less, ie clearly going for full deck
            if (missingCards.length > 0 && missingCards.length <= 6) {
                var msg = missingCards.length + " missing: " + missingCards.slice(0,3).join(" ");
                if (missingCards.length > 3) {
                    msg += "...";
                }
                cardDetail.push(msg);
            }
            // Add card details to typeStr
            if (cardDetail.length > 0) {
                typeStr += " (" + cardDetail.join(", ") + ")";
            }
        }
        return typeStr;
    }

    function setQrEvents(els) {
        els.on("mouseenter", createQr);
        els.on("mouseleave", destroyQr);
        els.on("click", toggleQr);
    }

    function createQr(e) {
        var content = e.target.textContent || e.target.value;
        if (content) {
            var qrEl = libs.kjua({
                text: content,
                render: "canvas",
                size: 310,
                ecLevel: 'H',
            });
            DOM.qrImage.append(qrEl);
            if (!showQr) {
                DOM.qrHider.addClass("hidden");
            }
            else {
                DOM.qrHider.removeClass("hidden");
            }
            DOM.qrContainer.removeClass("hidden");
        }
    }

    function destroyQr() {
        DOM.qrImage.text("");
        DOM.qrContainer.addClass("hidden");
    }

    function toggleQr() {
        showQr = !showQr;
        DOM.qrHider.toggleClass("hidden");
        DOM.qrHint.toggleClass("hidden");
    }

    function bip44TabSelected() {
        return DOM.bip44tab.hasClass("active");
    }

    function bip32TabSelected() {
        return DOM.bip32tab.hasClass("active");
    }

    function networkIsEthereum() {
        var name = networks[DOM.network.val()].name;
        return (name == "ETH - Ethereum")
                    || (name == "ETC - Ethereum Classic")
                    || (name == "EWT - EnergyWeb")
                    || (name == "PIRL - Pirl")
                    || (name == "MIX - MIX")
                    || (name == "MOAC - MOAC")
                    || (name == "MUSIC - Musicoin")
                    || (name == "POA - Poa")
                    || (name == "EXP - Expanse")
                    || (name == "CLO - Callisto")
                    || (name == "DXN - DEXON")
                    || (name == "ELLA - Ellaism")
                    || (name == "ESN - Ethersocial Network")
                    || (name == "VET - VeChain")
                    || (name == "ERE - EtherCore")
                    || (name == "BSC - Binance Smart Chain")
    }

    function networkIsRsk() {
        var name = networks[DOM.network.val()].name;
        return (name == "R-BTC - RSK")
            || (name == "tR-BTC - RSK Testnet");
    }

    function networkHasSegwit() {
        var n = network;
        if ("baseNetwork" in network) {
            n = libs.bitcoin.networks[network.baseNetwork];
        }
        // check if only p2wpkh params are required
        if (p2wpkhSelected()) {
            return "p2wpkh" in n;
        }
        // check if only p2wpkh-in-p2sh params are required
        else if (p2wpkhInP2shSelected()) {
            return "p2wpkhInP2sh" in n;
        }
        // require both if it's unclear which params are required
        return "p2wpkh" in n && "p2wpkhInP2sh" in n;
    }

    function bip49TabSelected() {
        return DOM.bip49tab.hasClass("active");
    }

    function bip84TabSelected() {
        return DOM.bip84tab.hasClass("active");
    }

    function bip141TabSelected() {
        return DOM.bip141tab.hasClass("active");
    }

    function setHdCoin(coinValue) {
        DOM.bip44coin.val(coinValue);
        DOM.bip49coin.val(coinValue);
        DOM.bip84coin.val(coinValue);
    }

    function showSegwitAvailable() {
        DOM.bip49unavailable.addClass("hidden");
        DOM.bip49available.removeClass("hidden");
        DOM.bip84unavailable.addClass("hidden");
        DOM.bip84available.removeClass("hidden");
        DOM.bip141unavailable.addClass("hidden");
        DOM.bip141available.removeClass("hidden");
    }

    function showSegwitUnavailable() {
        DOM.bip49available.addClass("hidden");
        DOM.bip49unavailable.removeClass("hidden");
        DOM.bip84available.addClass("hidden");
        DOM.bip84unavailable.removeClass("hidden");
        DOM.bip141available.addClass("hidden");
        DOM.bip141unavailable.removeClass("hidden");
    }

    function adjustNetworkForSegwit() {
        // If segwit is selected the xpub/xprv prefixes need to be adjusted
        // to avoid accidentally importing BIP49 xpub to BIP44 watch only
        // wallet.
        // See https://github.com/iancoleman/bip39/issues/125
        var segwitNetworks = null;
        // if a segwit network is alread selected, need to use base network to
        // look up new parameters
        if ("baseNetwork" in network) {
            network = libs.bitcoin.networks[network.baseNetwork];
        }
        // choose the right segwit params
        if (p2wpkhSelected() && "p2wpkh" in network) {
            network = network.p2wpkh;
        }
        else if (p2wpkhInP2shSelected() && "p2wpkhInP2sh" in network) {
            network = network.p2wpkhInP2sh;
        }
        else if (p2wshSelected() && "p2wsh" in network) {
            network = network.p2wsh;
        }
        else if (p2wshInP2shSelected() && "p2wshInP2sh" in network) {
            network = network.p2wshInP2sh;
        }
    }

    function lastIndexInTable() {
        var pathText = DOM.addresses.find(".index").last().text();
        var pathBits = pathText.split("/");
        var lastBit = pathBits[pathBits.length-1];
        var lastBitClean = lastBit.replace("'", "");
        return parseInt(lastBitClean);
    }

    function uint8ArrayToHex(a) {
        var s = ""
        for (var i=0; i<a.length; i++) {
            var h = a[i].toString(16);
            while (h.length < 2) {
                h = "0" + h;
            }
            s = s + h;
        }
        return s;
    }

    function showWordIndexes() {
        var phrase = DOM.phrase.val();
        var words = phraseToWordArray(phrase);
        var wordIndexes = [];
        var language = getLanguage();
        for (var i=0; i<words.length; i++) {
            var word = words[i];
            var wordIndex = WORDLISTS[language].indexOf(word);
            wordIndexes.push(wordIndex);
        }
        var wordIndexesStr = wordIndexes.join(", ");
        DOM.entropyWordIndexes.text(wordIndexesStr);
    }

    function showChecksum() {
        var phrase = DOM.phrase.val();
        // console.log(phrase);
        var words = phraseToWordArray(phrase);
        var checksumBitlength = words.length / 3;
        var checksum = "";
        var binaryStr = "";
        var language = getLanguage();
        for (var i=words.length-1; i>=0; i--) {
            var word = words[i];
            var wordIndex = WORDLISTS[language].indexOf(word);
            var wordBinary = wordIndex.toString(2);
            while (wordBinary.length < 11) {
                wordBinary = "0" + wordBinary;
            }
            var binaryStr = wordBinary + binaryStr;
            if (binaryStr.length >= checksumBitlength) {
                var start = binaryStr.length - checksumBitlength;
                var end = binaryStr.length;
                checksum = binaryStr.substring(start, end);
                // add spaces so the last group is 11 bits, not the first
                checksum = checksum.split("").reverse().join("")
                checksum = addSpacesEveryElevenBits(checksum);
                checksum = checksum.split("").reverse().join("")
                break;
            }
        }
        DOM.entropyChecksum.text(checksum);
    }

    function updateCsv() {
        var tableCsv = "path,address,public key,private key\n";
        var rows = DOM.addresses.find("tr");
        for (var i=0; i<rows.length; i++) {
            var row = $(rows[i]);
            var cells = row.find("td");
            for (var j=0; j<cells.length; j++) {
                var cell = $(cells[j]);
                if (!cell.children().hasClass("invisible")) {
                    tableCsv = tableCsv + cell.text();
                }
                if (j != cells.length - 1) {
                    tableCsv = tableCsv + ",";
                }
            }
            tableCsv = tableCsv + "\n";
        }
        DOM.csv.val(tableCsv);
    }

    function addSpacesEveryElevenBits(binaryStr) {
        return binaryStr.match(/.{1,11}/g).join(" ");
    }

    var networks = [
        {
            name: "BTC - Bitcoin",
            onSelect: function() {
                network = libs.bitcoin.networks.bitcoin;
                setHdCoin(0);
            },
        },
        {
            name: "BTC - Bitcoin RegTest",
            onSelect: function() {
                network = libs.bitcoin.networks.regtest;
                // Using hd coin value 1 based on bip44_coin_type
                // https://github.com/chaintope/bitcoinrb/blob/f1014406f6b8f9b4edcecedc18df70c80df06f11/lib/bitcoin/chainparams/regtest.yml
                setHdCoin(1);
            },
        },
        {
            name: "BTC - Bitcoin Testnet",
            onSelect: function() {
                network = libs.bitcoin.networks.testnet;
                setHdCoin(1);
            },
        }
    ]

    var clients = [
        {
            name: "Bitcoin Core",
            onSelect: function() {
                DOM.bip32path.val("m/0'/0'");
                DOM.hardenedAddresses.prop('checked', true);
            },
        },
        {
            name: "blockchain.info",
            onSelect: function() {
                DOM.bip32path.val("m/44'/0'/0'");
                DOM.hardenedAddresses.prop('checked', false);
            },
        },
        {
            name: "MultiBit HD",
            onSelect: function() {
                DOM.bip32path.val("m/0'/0");
                DOM.hardenedAddresses.prop('checked', false);
            },
        },
        {
            name: "Coinomi, Ledger",
            onSelect: function() {
                DOM.bip32path.val("m/44'/"+DOM.bip44coin.val()+"'/0'");
                DOM.hardenedAddresses.prop('checked', false);
            },
        }
    ]

    // RSK - RSK functions - begin
    function stripHexPrefix(address) {
        if (typeof address !== "string") {
            throw new Error("address parameter should be a string.");
        }

        var hasPrefix = (address.substring(0, 2) === "0x" ||
            address.substring(0, 2) === "0X");

        return hasPrefix ? address.slice(2) : address;
    };

    function toChecksumAddressForRsk(address, chainId = null) {
        if (typeof address !== "string") {
            throw new Error("address parameter should be a string.");
        }

        if (!/^(0x)?[0-9a-f]{40}$/i.test(address)) {
            throw new Error("Given address is not a valid RSK address: " + address);
        }

        var stripAddress = stripHexPrefix(address).toLowerCase();
        var prefix = chainId != null ? chainId.toString() + "0x" : "";
        var keccakHash = libs.ethUtil.keccak256(prefix + stripAddress)
            .toString("hex")
            .replace(/^0x/i, "");
        var checksumAddress = "0x";

        for (var i = 0; i < stripAddress.length; i++) {
            checksumAddress +=
                parseInt(keccakHash[i], 16) >= 8 ?
                stripAddress[i].toUpperCase() :
                stripAddress[i];
        }

        return checksumAddress;
    }

    // RSK - RSK functions - end

    // ELA - Elastos functions - begin
    function displayBip44InfoForELA() {
        if (!isELA()) {
            return;
        }

        var coin = parseIntNoNaN(DOM.bip44coin.val(), 0);
        var account = parseIntNoNaN(DOM.bip44account.val(), 0);

        // Calculate the account extended keys
        var accountXprv = libs.elastosjs.getAccountExtendedPrivateKey(seed, coin, account);
        var accountXpub = libs.elastosjs.getAccountExtendedPublicKey(seed, coin, account);

        // Display the extended keys
        DOM.bip44accountXprv.val(accountXprv);
        DOM.bip44accountXpub.val(accountXpub);
    }

    function displayBip32InfoForELA() {
        if (!isELA()) {
            return;
        }

        var coin = parseIntNoNaN(DOM.bip44coin.val(), 0);
        var account = parseIntNoNaN(DOM.bip44account.val(), 0);
        var change = parseIntNoNaN(DOM.bip44change.val(), 0);

        DOM.extendedPrivKey.val(libs.elastosjs.getBip32ExtendedPrivateKey(seed, coin, account, change));
        DOM.extendedPubKey.val(libs.elastosjs.getBip32ExtendedPublicKey(seed, coin, account, change));

        // Display the addresses and privkeys
        clearAddressesList();
        var initialAddressCount = parseInt(DOM.rowsToAdd.val());
        displayAddresses(0, initialAddressCount);
    }

    function calcAddressForELA(seed, coin, account, change, index) {
        if (!isELA()) {
            return;
        }

        var publicKey = libs.elastosjs.getDerivedPublicKey(libs.elastosjs.getMasterPublicKey(seed), change, index);
        return {
            privateKey: libs.elastosjs.getDerivedPrivateKey(seed, coin, account, change, index),
            publicKey: publicKey,
            address: libs.elastosjs.getAddress(publicKey.toString('hex'))
        };
    }
    // ELA - Elastos functions - end

    init();

})();
</script>
    

</body></html>